{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _nextUtil = require('../../../next-util/lib/index.js');\n\nvar _nextDom = require('../../../next-dom/lib/index.js');\n\nvar _nextDom2 = _interopRequireDefault(_nextDom);\n\nvar _eventHandlers = require('./mixins/event-handlers.js');\n\nvar _eventHandlers2 = _interopRequireDefault(_eventHandlers);\n\nvar _helpers = require('./mixins/helpers.js');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _utils = require('../utils/utils.js');\n\nvar _track = require('./track.js');\n\nvar _track2 = _interopRequireDefault(_track);\n\nvar _dots = require('./dots.js');\n\nvar _dots2 = _interopRequireDefault(_dots);\n\nvar _prevArrow = require('./prev-arrow.js');\n\nvar _prevArrow2 = _interopRequireDefault(_prevArrow);\n\nvar _nextArrow = require('./next-arrow.js');\n\nvar _nextArrow2 = _interopRequireDefault(_nextArrow);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n}\n\nvar noop = function noop() {};\n\nvar InnerSlider = (_temp = _class = function (_React$Component) {\n  _inherits(InnerSlider, _React$Component);\n\n  function InnerSlider(props, context) {\n    _classCallCheck(this, InnerSlider);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    _this.state = {\n      animating: false,\n      dragging: false,\n      autoPlayTimer: null,\n      currentDirection: 0,\n      currentLeft: null,\n      currentSlide: _this.props.initialSlide,\n      direction: 1,\n      listWidth: null,\n      listHeight: null,\n      slideCount: null,\n      slideWidth: null,\n      slideHeight: null,\n      swipeLeft: null,\n      touchObject: {\n        startX: 0,\n        startY: 0,\n        curX: 0,\n        curY: 0\n      },\n      lazyLoadedList: [],\n      // added for react\n      initialized: false,\n      edgeDragged: false,\n      swiped: false,\n      // used by swipeEvent. differentites between touch and swipe.\n      trackStyle: {},\n      trackWidth: 0\n    };\n    _this.onWindowResized = _this.onWindowResized.bind(_this);\n    return _this;\n  }\n\n  InnerSlider.prototype.componentWillMount = function componentWillMount() {\n    this.setState({\n      mounted: true\n    });\n    var lazyLoadedList = [];\n\n    for (var i = 0; i < _react2['default'].Children.count(this.props.children); i++) {\n      if (i >= this.state.currentSlide && i < this.state.currentSlide + this.props.slidesToShow) {\n        lazyLoadedList.push(i);\n      }\n    }\n\n    if (this.props.lazyLoad && this.state.lazyLoadedList.length === 0) {\n      this.setState({\n        lazyLoadedList: lazyLoadedList\n      });\n    }\n  };\n\n  InnerSlider.prototype.componentDidMount = function componentDidMount() {\n    // Hack for autoplay -- Inspect Later\n    this.initialize(this.props);\n    this.adaptHeight(); // Fallback for IE8\n\n    this._setArrowPositonForIE8(this.props, _utils.isIE8); // 1.x TODO: remove slickGoTo\n\n\n    if (this.props.slickGoTo) {\n      this.slickGoTo(this.props.slickGoTo);\n    }\n    /* istanbul ignore if  */\n\n\n    if (!window) {\n      // To support server-side rendering\n      return;\n    }\n\n    _nextDom2['default'].events.on(window, 'resize', this.onWindowResized);\n  };\n\n  InnerSlider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.initialSlide !== nextProps.initialSlide) {\n      this.setState({\n        currentSlide: nextProps.initialSlide\n      });\n    }\n\n    if (this.props.slickGoTo !== nextProps.slickGoTo) {\n      this.slickGoTo(nextProps.slickGoTo);\n    } else if (this.state.currentSlide >= nextProps.children.length) {\n      this.update(nextProps);\n      this.changeSlide({\n        message: 'index',\n        index: nextProps.children.length - nextProps.slidesToShow,\n        currentSlide: this.state.currentSlide\n      });\n    } else {\n      var resetSlide = _react2['default'].Children.count(this.props.children) !== _react2['default'].Children.count(nextProps.children);\n\n      this.update(nextProps, resetSlide);\n    }\n  };\n\n  InnerSlider.prototype.componentDidUpdate = function componentDidUpdate() {\n    this.adaptHeight();\n  };\n\n  InnerSlider.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.animationEndCallback) {\n      clearTimeout(this.animationEndCallback);\n    }\n\n    _nextDom2['default'].events.off(window, 'resize', this.onWindowResized);\n\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n  };\n\n  InnerSlider.prototype.onWindowResized = function onWindowResized() {\n    this.update(this.props, false); // Fallback for IE8\n\n    this._setArrowPositonForIE8(_utils.isIE8); // animating state should be cleared while resizing, otherwise autoplay stops working\n\n\n    this.setState({\n      animating: false\n    });\n    clearTimeout(this.animationEndCallback);\n    delete this.animationEndCallback;\n  };\n\n  InnerSlider.prototype.slickGoTo = function slickGoTo(slide) {\n    typeof slide === 'number' && this.changeSlide({\n      message: 'index',\n      index: slide,\n      currentSlide: this.state.currentSlide\n    });\n  };\n\n  InnerSlider.prototype.onEnterArrow = function onEnterArrow(msg) {\n    this.arrowHoverHandler(msg);\n  };\n\n  InnerSlider.prototype.onLeaveArrow = function onLeaveArrow() {\n    this.arrowHoverHandler();\n  };\n\n  InnerSlider.prototype._instanceRefHandler = function _instanceRefHandler(attr, ref) {\n    this[attr] = ref;\n  };\n\n  InnerSlider.prototype._setArrowPositonForIE8 = function _setArrowPositonForIE8(_ref, isIE8) {\n    var slideDirection = _ref.slideDirection;\n    /* istanbul ignore if  */\n\n    if (isIE8 && this.pArrow) {\n      var listElem = (0, _reactDom.findDOMNode)(this.list);\n      var pArrowElem = (0, _reactDom.findDOMNode)(this.pArrow);\n      var nArrowElem = (0, _reactDom.findDOMNode)(this.nArrow);\n      var listHeight = (0, _utils.getNodeHeight)(listElem);\n      var listWidth = (0, _utils.getNodeWidth)(listElem);\n      var arrowHeight = (0, _utils.getNodeHeight)(pArrowElem);\n      var arrowWidth = (0, _utils.getNodeWidth)(pArrowElem);\n\n      if (slideDirection === 'vertical') {\n        // 垂直滑动时\n        var arrowHorizontalPosition = (listWidth - arrowWidth) / 2 + 'px';\n        pArrowElem.style.top = 0;\n        pArrowElem.style.left = arrowHorizontalPosition;\n        nArrowElem.style.bottom = 0;\n        nArrowElem.style.left = arrowHorizontalPosition;\n      } else {\n        // 水平滑动时\n        var arrowVerticalPosition = (listHeight - arrowHeight) / 2 + 'px';\n        pArrowElem.style.top = arrowVerticalPosition;\n        nArrowElem.style.top = arrowVerticalPosition;\n      }\n    }\n  };\n\n  InnerSlider.prototype.render = function render() {\n    var _props = this.props,\n        prefix = _props.prefix,\n        animation = _props.animation,\n        arrows = _props.arrows,\n        arrowSize = _props.arrowSize,\n        arrowPos = _props.arrowPos,\n        arrowDirection = _props.arrowDirection,\n        dots = _props.dots,\n        dotsClass = _props.dotsClass,\n        fade = _props.fade,\n        cssEase = _props.cssEase,\n        speed = _props.speed,\n        infinite = _props.infinite,\n        centerMode = _props.centerMode,\n        lazyLoad = _props.lazyLoad,\n        dotsDirection = _props.dotsDirection,\n        rtl = _props.rtl,\n        slidesToShow = _props.slidesToShow,\n        slidesToScroll = _props.slidesToScroll,\n        variableWidth = _props.variableWidth,\n        vertical = _props.vertical,\n        focusOnSelect = _props.focusOnSelect,\n        children = _props.children,\n        others = _objectWithoutProperties(_props, ['prefix', 'animation', 'arrows', 'arrowSize', 'arrowPos', 'arrowDirection', 'dots', 'dotsClass', 'fade', 'cssEase', 'speed', 'infinite', 'centerMode', 'lazyLoad', 'dotsDirection', 'rtl', 'slidesToShow', 'slidesToScroll', 'variableWidth', 'vertical', 'focusOnSelect', 'children']);\n\n    var trackProps = {\n      prefix: prefix,\n      fade: fade,\n      cssEase: cssEase,\n      speed: speed,\n      infinite: infinite,\n      centerMode: centerMode,\n      focusOnSelect: focusOnSelect ? this.selectHandler.bind(this) : null,\n      currentSlide: this.state.currentSlide,\n      lazyLoad: lazyLoad,\n      lazyLoadedList: this.state.lazyLoadedList,\n      rtl: rtl,\n      slideWidth: this.state.slideWidth,\n      slideHeight: this.state.slideHeight,\n      slidesToShow: slidesToShow,\n      slidesToScroll: slidesToScroll,\n      slideCount: this.state.slideCount,\n      trackStyle: this.state.trackStyle,\n      variableWidth: variableWidth,\n      vertical: vertical,\n      clickHandler: this.changeSlide.bind(this)\n    };\n    var dotsEle = void 0;\n\n    if (dots === true && this.state.slideCount > slidesToShow) {\n      var dotProps = {\n        prefix: prefix,\n        dotsClass: dotsClass,\n        slideCount: this.state.slideCount,\n        slidesToShow: slidesToShow,\n        currentSlide: this.state.currentSlide,\n        slidesToScroll: slidesToScroll,\n        dotsDirection: dotsDirection,\n        clickHandler: this.changeSlide.bind(this)\n      };\n      dotsEle = _react2['default'].createElement(_dots2['default'], dotProps);\n    }\n\n    var prevArrow = void 0,\n        nextArrow = void 0;\n    var arrowProps = {\n      prefix: prefix,\n      arrowSize: arrowSize,\n      arrowPos: arrowPos,\n      arrowDirection: arrowDirection,\n      infinite: infinite,\n      centerMode: centerMode,\n      currentSlide: this.state.currentSlide,\n      slideCount: this.state.slideCount,\n      slidesToShow: slidesToShow,\n      prevArrow: this.props.prevArrow,\n      nextArrow: this.props.nextArrow,\n      clickHandler: this.changeSlide.bind(this)\n    };\n\n    if (arrows) {\n      prevArrow = _react2['default'].createElement(_prevArrow2['default'], _extends({}, arrowProps, {\n        ref: this._instanceRefHandler.bind(this, 'pArrow'),\n        onMouseEnter: animation ? this.onEnterArrow.bind(this, 'prev') : noop,\n        onMouseLeave: animation ? this.onLeaveArrow.bind(this, 'prev') : noop\n      }));\n      nextArrow = _react2['default'].createElement(_nextArrow2['default'], _extends({}, arrowProps, {\n        ref: this._instanceRefHandler.bind(this, 'nArrow'),\n        onMouseEnter: animation ? this.onEnterArrow.bind(this, 'next') : noop,\n        onMouseLeave: animation ? this.onLeaveArrow.bind(this, 'next') : noop\n      }));\n    }\n\n    var verticalHeightStyle = null;\n\n    if (vertical) {\n      verticalHeightStyle = {\n        height: this.state.listHeight\n      };\n    }\n\n    var centerPaddingStyle = void 0;\n\n    if (centerMode) {\n      centerPaddingStyle = vertical ? {\n        padding: this.props.centerPadding + ' 0px'\n      } : {\n        padding: '0px ' + this.props.centerPadding\n      };\n    }\n\n    var listStyle = _extends({}, verticalHeightStyle, centerPaddingStyle);\n\n    return _react2['default'].createElement('div', _extends({}, (0, _nextUtil.pickAttrs)(others), {\n      className: prefix + 'slick-inner ' + prefix + 'slick-initialized',\n      onMouseEnter: this.onInnerSliderEnter.bind(this),\n      onMouseLeave: this.onInnerSliderLeave.bind(this)\n    }), _react2['default'].createElement('div', {\n      ref: this._instanceRefHandler.bind(this, 'list'),\n      className: prefix + 'slick-list',\n      style: listStyle,\n      onMouseDown: this.swipeStart.bind(this),\n      onMouseMove: this.state.dragging ? this.swipeMove.bind(this) : null,\n      onMouseUp: this.swipeEnd.bind(this),\n      onMouseLeave: this.state.dragging ? this.swipeEnd.bind(this) : null,\n      onTouchStart: this.swipeStart.bind(this),\n      onTouchMove: this.state.dragging ? this.swipeMove.bind(this) : null,\n      onTouchEnd: this.swipeEnd.bind(this),\n      onTouchCancel: this.state.dragging ? this.swipeEnd.bind(this) : null\n    }, _react2['default'].createElement(_track2['default'], _extends({\n      ref: this._instanceRefHandler.bind(this, 'track')\n    }, trackProps), children)), prevArrow, nextArrow, dotsEle);\n  };\n\n  return InnerSlider;\n}(_react2['default'].Component), _class.propTypes = {\n  prefix: _propTypes2['default'].string,\n  animation: _propTypes2['default'].bool,\n  arrows: _propTypes2['default'].bool,\n  arrowSize: _propTypes2['default'].oneOf(['medium', 'large']),\n  arrowPos: _propTypes2['default'].oneOf(['inline', 'outer']),\n  arrowDirection: _propTypes2['default'].oneOf(['horizontal', 'vertical']),\n  centerPadding: _propTypes2['default'].any,\n  children: _propTypes2['default'].any,\n  centerMode: _propTypes2['default'].bool,\n  dots: _propTypes2['default'].bool,\n  dotsDirection: _propTypes2['default'].oneOf(['horizontal', 'vertical']),\n  dotsClass: _propTypes2['default'].string,\n  fade: _propTypes2['default'].bool,\n  focusOnSelect: _propTypes2['default'].bool,\n  cssEase: _propTypes2['default'].string,\n  speed: _propTypes2['default'].number,\n  infinite: _propTypes2['default'].bool,\n  initialSlide: _propTypes2['default'].number,\n  rtl: _propTypes2['default'].bool,\n  slidesToShow: _propTypes2['default'].number,\n  lazyLoad: _propTypes2['default'].bool,\n  slickGoTo: _propTypes2['default'].number,\n  slidesToScroll: _propTypes2['default'].number,\n  variableWidth: _propTypes2['default'].bool,\n  vertical: _propTypes2['default'].bool,\n  prevArrow: _propTypes2['default'].element,\n  nextArrow: _propTypes2['default'].element\n}, _class.defaultProps = {\n  prefix: 'next-',\n  arrowDirection: 'horizontal'\n}, _temp);\nInnerSlider.displayName = 'InnerSlider';\n(0, _utils.mixinTo)(InnerSlider, _helpers2['default']);\n(0, _utils.mixinTo)(InnerSlider, _eventHandlers2['default']);\nexports['default'] = InnerSlider;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}