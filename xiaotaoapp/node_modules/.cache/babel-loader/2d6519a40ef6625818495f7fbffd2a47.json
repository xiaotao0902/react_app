{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _nextDom = require('../../next-dom/lib/index.js');\n\nvar _nextUtil = require('../../next-util/lib/index.js');\n\nvar _classnames3 = require('classnames');\n\nvar _classnames4 = _interopRequireDefault(_classnames3);\n\nvar _manager = require('./manager.js');\n\nvar _manager2 = _interopRequireDefault(_manager);\n\nvar _gateway = require('./gateway.js');\n\nvar _gateway2 = _interopRequireDefault(_gateway);\n\nvar _position = require('./position.js');\n\nvar _position2 = _interopRequireDefault(_position);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n}\n\nvar REACT_VERSION = parseInt(_react2['default'].version, 10);\n\nvar Children = _react2['default'].Children,\n    makeChain = _nextUtil.func.makeChain,\n    noop = function noop() {},\n    saveLastFocusNode = _nextUtil.focus.saveLastFocusNode,\n    getFocusNodeList = _nextUtil.focus.getFocusNodeList,\n    backLastFocusNode = _nextUtil.focus.backLastFocusNode,\n    ANIMATION_CLS = 'animated';\n\nvar isScrollDisplay = function isScrollDisplay(element) {\n  try {\n    var scrollbarStyle = window.getComputedStyle(element, '::-webkit-scrollbar');\n    return !scrollbarStyle || scrollbarStyle.getPropertyValue('display') !== 'none';\n  } catch (e) {// ignore error for firefox\n  }\n\n  return true;\n};\n\nvar hasScroll = function hasScroll() {\n  var doc = document.documentElement;\n  return doc.scrollHeight > doc.clientHeight && (0, _nextUtil.scrollbar)().width > 0 && isScrollDisplay(document.documentElement) && isScrollDisplay(document.body);\n};\n\nvar modals = [];\nvar bodyOverflowY = void 0,\n    bodyPaddingRight = void 0; // <Overlay>\n//  <content></content>\n// </Overlay>\n\n/** Overlay */\n\nvar Overlay = (_temp = _class = function (_React$Component) {\n  _inherits(Overlay, _React$Component);\n\n  Overlay.prototype.getPrefix = function getPrefix() {\n    return this.context.prefix || this.props.prefix;\n  };\n\n  function Overlay(props, context) {\n    _classCallCheck(this, Overlay);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    _this.state = {\n      visible: props.visible\n    };\n    _this.Manager = _manager2['default'];\n    _this._onDocumentKeyDown = _this._onDocumentKeyDown.bind(_this);\n    _this._onDocumentClick = _this._onDocumentClick.bind(_this);\n    _this._onMaskClick = _this._onMaskClick.bind(_this);\n    _this._onPosition = _this._onPosition.bind(_this);\n    _this._safeClickNode = [];\n    _this.beforeOpen = _this.beforeOpen.bind(_this);\n    _this.beforeClose = _this.beforeClose.bind(_this);\n    _this.onAnimateEnd = _this.onAnimateEnd.bind(_this);\n    return _this;\n  }\n\n  Overlay.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (!this._isMounted && nextProps.visible) {\n      this._isMounted = true;\n    }\n\n    var willOpen = !this.state.visible && nextProps.visible;\n    var willClose = this.state.visible && this.state.animationType !== 'out' && !nextProps.visible;\n\n    if (willOpen) {\n      this.beforeOpen();\n      nextProps.beforeOpen();\n    } else if (willClose) {\n      this.beforeClose();\n      nextProps.beforeClose();\n    }\n\n    if (nextProps.animation && _nextUtil.support.animation) {\n      if (willOpen) {\n        this.enter();\n      } else if (willClose) {\n        this.leave();\n      }\n    } else {\n      this.setState({\n        visible: nextProps.visible\n      });\n    }\n  };\n\n  Overlay.prototype.componentWillMount = function componentWillMount() {\n    if (this.props.visible) {\n      this.beforeOpen();\n      this.props.beforeOpen();\n\n      if (this.props.animation && _nextUtil.support.animation) {\n        this.enter();\n      }\n    }\n  };\n\n  Overlay.prototype._initAnimationEvents = function _initAnimationEvents(flag) {\n    var node = this.getContentNode(); // react 16 中，在 componentDidMount 中调用初始化方法中并不能保证节点完成渲染\n\n    if (REACT_VERSION > 15 && !node && flag !== 'try') {\n      return setTimeout(this._initAnimationEvents.bind(this, 'try'));\n    }\n\n    if (node) {\n      this._animation = _nextDom.events.on(node, _nextUtil.support.animation.end, this.onAnimateEnd);\n    }\n  };\n\n  Overlay.prototype.enter = function enter() {\n    var _this2 = this;\n\n    this.setState({\n      visible: true,\n      animationType: 'in'\n    }, function () {\n      if (REACT_VERSION > 15) {\n        // in react 16, callback will be called before DOM mounted.\n        setTimeout(function () {\n          !_this2.isDestroyed && _this2.onEntering && _this2.onEntering();\n        });\n      } else {\n        _this2.onEntering && _this2.onEntering();\n      }\n    });\n  };\n\n  Overlay.prototype.leave = function leave() {\n    this.setState({\n      animationType: 'out'\n    });\n    this.onLeaving && this.onLeaving();\n  };\n\n  Overlay.prototype.onAnimateEnd = function onAnimateEnd() {\n    if (this.state.animationType === 'out') {\n      this.setState({\n        visible: false,\n        animationType: 'none'\n      });\n      this.onLeaved && this.onLeaved();\n    } else if (this.state.animationType === 'in') {\n      this.setState({\n        animationType: 'none'\n      });\n      this.onEntered && this.onEntered();\n    }\n  };\n\n  Overlay.prototype.getAnimationCls = function getAnimationCls(config) {\n    var className = void 0;\n\n    switch (this.state.animationType) {\n      case 'in':\n        className = ANIMATION_CLS + ' ' + config['in'];\n        break;\n\n      case 'out':\n        className = ANIMATION_CLS + ' ' + config.out;\n        break;\n\n      case 'none':\n        className = '';\n    }\n\n    return className;\n  };\n\n  Overlay.prototype.getContentNode = function getContentNode() {\n    return _reactDom2['default'].findDOMNode(this.getContent());\n  };\n\n  Overlay.prototype.getContent = function getContent() {\n    return this.content || this.refs[this.contentRef];\n  };\n\n  Overlay.prototype.getWrapperNode = function getWrapperNode() {\n    return this.refs.gateway ? this.refs.gateway.getContentNode() : null;\n  };\n\n  Overlay.prototype.render = function render() {\n    var _this3 = this;\n    /* eslint-disable no-unused-vars */\n\n\n    var _props = this.props,\n        animation = _props.animation,\n        cache = _props.cache,\n        container = _props.container,\n        className = _props.className,\n        style = _props.style,\n        hasMask = _props.hasMask,\n        shouldUpdatePosition = _props.shouldUpdatePosition,\n        target = _props.target,\n        offset = _props.offset,\n        align = _props.align,\n        onPosition = _props.onPosition,\n        beforePosition = _props.beforePosition,\n        needAdjust = _props.needAdjust,\n        children = _props.children,\n        safeId = _props.safeId,\n        canCloseByOutSideClick = _props.canCloseByOutSideClick,\n        canCloseByEsc = _props.canCloseByEsc,\n        visible = _props.visible,\n        beforeOpen = _props.beforeOpen,\n        beforeClose = _props.beforeClose,\n        afterOpen = _props.afterOpen,\n        afterClose = _props.afterClose,\n        onOpen = _props.onOpen,\n        onClose = _props.onClose,\n        onRequestClose = _props.onRequestClose,\n        wrapperCls = _props.wrapperClassName,\n        others = _objectWithoutProperties(_props, ['animation', 'cache', 'container', 'className', 'style', 'hasMask', 'shouldUpdatePosition', 'target', 'offset', 'align', 'onPosition', 'beforePosition', 'needAdjust', 'children', 'safeId', 'canCloseByOutSideClick', 'canCloseByEsc', 'visible', 'beforeOpen', 'beforeClose', 'afterOpen', 'afterClose', 'onOpen', 'onClose', 'onRequestClose', 'wrapperClassName']),\n        prefix = this.getPrefix(),\n        animationCls = void 0,\n        cls = void 0,\n        child = void 0,\n        wrapperClassName = void 0;\n\n    children = this.state.visible || cache && this._isMounted ? children : null;\n    onPosition = makeChain(this._onPosition, onPosition);\n\n    if (animation && _nextUtil.support.animation) {\n      animationCls = this.getAnimationCls(animation);\n    } else {\n      animationCls = false;\n    }\n\n    if (children) {\n      var _classnames, _classnames2;\n\n      child = Children.only(children); // eslint-disable-next-line\n\n      cls = (0, _classnames4['default'])((_classnames = {}, _defineProperty(_classnames, prefix + 'overlay-inner', true), _defineProperty(_classnames, animationCls, animationCls), _defineProperty(_classnames, child.props.className, child.props.className), _defineProperty(_classnames, className, className), _classnames)), wrapperClassName = (0, _classnames4['default'])((_classnames2 = {}, _defineProperty(_classnames2, prefix + 'overlay-wrapper', true), _defineProperty(_classnames2, wrapperCls, wrapperCls), _classnames2));\n      var ref = void 0;\n\n      if (child.ref) {\n        if (typeof child.ref === 'function') {\n          ref = function ref(_ref) {\n            _this3.content = _ref;\n            child.ref(_ref);\n          };\n        } else {\n          ref = this.contentRef = child.ref;\n        }\n      } else {\n        ref = this.contentRef = 'content';\n      }\n\n      children = _react2['default'].cloneElement(child, {\n        className: cls,\n        ref: ref,\n        id: child.props.id ? child.props.id : safeId,\n        style: _extends({}, style || {}, child.props.style || {})\n      });\n\n      if (this.state.animationType === 'out') {\n        shouldUpdatePosition = false;\n      }\n\n      if (this.props.align) {\n        children = _react2['default'].createElement(_position2['default'], {\n          target: target,\n          offset: offset,\n          align: align,\n          beforePosition: beforePosition,\n          onPosition: onPosition,\n          needAdjust: needAdjust,\n          shouldUpdatePosition: shouldUpdatePosition\n        }, children);\n      }\n\n      children = _react2['default'].createElement('div', {\n        className: wrapperClassName,\n        style: {\n          display: this.state.visible ? '' : 'none'\n        }\n      }, hasMask ? _react2['default'].createElement('div', {\n        className: prefix + 'overlay-backdrop',\n        onClick: this._onMaskClick\n      }) : null, children);\n    }\n\n    return _react2['default'].createElement(_gateway2['default'], {\n      container: container,\n      ref: 'gateway',\n      target: target\n    }, children);\n  };\n\n  Overlay.prototype.beforeOpen = function beforeOpen() {\n    if (this.props.disableScroll) {\n      if (modals.length === 0) {\n        var value = {\n          overflowY: 'hidden'\n        };\n        var body = document.body;\n        bodyOverflowY = body.style.overflowY;\n\n        if (hasScroll()) {\n          bodyPaddingRight = body.style.paddingRight;\n          value.paddingRight = _nextDom.style.get(body, 'paddingRight') + (0, _nextUtil.scrollbar)().width + 'px';\n        }\n\n        _nextDom.style.set(body, value);\n      }\n\n      modals.push(this);\n    }\n  };\n\n  Overlay.prototype.beforeClose = function beforeClose() {\n    if (this.props.disableScroll) {\n      var index = modals.indexOf(this);\n\n      if (index > -1) {\n        if (modals.length === 1) {\n          var value = {\n            overflowY: bodyOverflowY\n          };\n\n          if (hasScroll()) {\n            value.paddingRight = bodyPaddingRight;\n          }\n\n          _nextDom.style.set(document.body, value);\n\n          bodyOverflowY = undefined;\n          bodyPaddingRight = undefined;\n        }\n\n        modals.splice(index, 1);\n      }\n    }\n  };\n\n  Overlay.prototype.componentDidMount = function componentDidMount() {\n    //如果设置了动画，需要等到动画执行完毕再设置焦点\n    //使用onEntered方法\n    this.componentDidUpdate();\n  };\n\n  Overlay.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var _this4 = this;\n\n    if (this.props.animation && _nextUtil.support.animation) {\n      this._initAnimationEvents();\n    } else {\n      var callback = function callback() {\n        var wrapperNode = _this4.getWrapperNode();\n\n        _this4._setFocusNode(prevProps, prevState);\n\n        if (_this4.state.visible) {\n          _this4.props.onOpen();\n\n          _this4.props.afterOpen();\n\n          wrapperNode && _nextDom.classList.addClass(wrapperNode, 'opened');\n\n          _manager2['default'].addOverlay(_this4);\n        } else if (prevState && prevState.visible === true) {\n          _this4.props.onClose();\n\n          _this4.props.afterClose();\n\n          wrapperNode && _nextDom.classList.removeClass(wrapperNode, 'opened');\n\n          _manager2['default'].removeOverlay(_this4);\n        }\n      };\n\n      if (REACT_VERSION > 15) {\n        setTimeout(callback);\n      } else {\n        callback();\n      }\n    }\n\n    this.prevProps = prevProps;\n    this.prevState = prevState;\n    this.handleDocumentEvents();\n  };\n\n  Overlay.prototype.handleDocumentEvents = function handleDocumentEvents() {\n    if (this.state.visible) {\n      if (this.props.canCloseByEsc && !this._keydownEvents) {\n        this._keydownEvents = _nextDom.events.on(document, 'keydown', this._onDocumentKeyDown);\n      }\n\n      if (this.props.canCloseByOutSideClick && !this._documentEvents) {\n        this._documentEvents = _nextDom.events.on(document, 'click', this._onDocumentClick);\n      }\n\n      return;\n    }\n\n    this.clearHandleDocumentEvents();\n  };\n\n  Overlay.prototype.clearHandleDocumentEvents = function clearHandleDocumentEvents() {\n    if (this._keydownEvents) {\n      this._keydownEvents.off();\n\n      this._keydownEvents = null;\n    }\n\n    if (this._documentEvents) {\n      this._documentEvents.off();\n\n      this._documentEvents = null;\n    }\n  };\n\n  Overlay.prototype.onEntering = function onEntering() {\n    var wrapperNode = this.getWrapperNode();\n    this.props.onOpen();\n    wrapperNode && _nextDom.classList.addClass(wrapperNode, 'opened');\n  };\n\n  Overlay.prototype.onLeaving = function onLeaving() {\n    var wrapperNode = this.getWrapperNode();\n    this.props.onClose();\n    wrapperNode && _nextDom.classList.removeClass(wrapperNode, 'opened');\n  };\n\n  Overlay.prototype.onEntered = function onEntered() {\n    this._setFocusNode(this.prevProps, this.prevState);\n\n    this.props.afterOpen();\n\n    _manager2['default'].addOverlay(this);\n  };\n\n  Overlay.prototype.onLeaved = function onLeaved() {\n    this._setFocusNode(this.prevProps, this.prevState);\n\n    this.props.afterClose();\n\n    _manager2['default'].removeOverlay(this);\n  }; //保留弹出层之前的焦点\n  //当弹层消失的时候返回之前的焦点\n\n\n  Overlay.prototype._setFocusNode = function _setFocusNode(prevProps, prevState) {\n    var _this5 = this;\n\n    var oldState = prevState || {};\n\n    if (this.props.autoFocus) {\n      if (this.state.visible && !this._hasFocused) {\n        saveLastFocusNode(); //这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经back触发的元素\n        //这里延时处理一下，延时的时间为document.click捕获触发的延时时间\n\n        this.focusTimeout = setTimeout(function () {\n          var node = _this5.getContentNode();\n\n          if (node) {\n            var focusNodeList = getFocusNodeList(node);\n\n            if (focusNodeList.length) {\n              focusNodeList[0].focus();\n            }\n\n            _this5._hasFocused = true;\n          }\n        }, 100);\n      } else if (!this.state.visible && this._hasFocused) {\n        backLastFocusNode();\n        this._hasFocused = false;\n      }\n    }\n  };\n\n  Overlay.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.isDestroyed = true;\n\n    _manager2['default'].removeOverlay(this);\n\n    this._isMounted = false;\n    this.clearHandleDocumentEvents();\n\n    if (this.focusTimeout) {\n      clearTimeout(this.focusTimeout);\n    }\n\n    if (this._animation) {\n      if (this._animation.off) {\n        this._animation.off();\n      }\n\n      this._animation = null;\n    }\n\n    this.beforeClose();\n  };\n\n  Overlay.prototype._onMaskClick = function _onMaskClick(e) {\n    if (this.props.canCloseByMask) {\n      this.props.onRequestClose('maskClick', e);\n    }\n  };\n\n  Overlay.prototype._getSafeNode = function _getSafeNode(safeNode) {\n    if (typeof safeNode === 'function') {\n      safeNode = safeNode(this.props);\n    }\n\n    if (typeof safeNode === 'string') {\n      safeNode = document.getElementById(safeNode);\n    } else {\n      try {\n        safeNode = _reactDom2['default'].findDOMNode(safeNode);\n      } catch (e) {// regardless of error\n      }\n    }\n\n    return safeNode;\n  };\n\n  Overlay.prototype._onDocumentKeyDown = function _onDocumentKeyDown(e) {\n    if (e.keyCode === 27) {\n      if (this.Manager && this.Manager.isCurrentOverlay(this) || !this.Manager) {\n        this.props.onRequestClose('keyboard', e);\n      }\n    }\n  };\n\n  Overlay.prototype._onDocumentClick = function _onDocumentClick(e) {\n    this.initSafeNode();\n\n    for (var i = 0; i < this._safeClickNode.length; i++) {\n      var node = this._safeClickNode[i],\n          nodeGroup = node.getAttribute('data-overlay-group'),\n          _target = e.target,\n          targetGroup = _target.getAttribute && _target.getAttribute('data-overlay-group') || '';\n\n      if (node.contains(_target) || nodeGroup === targetGroup || node === _target || !document.documentElement.contains(e.target)) {\n        return;\n      }\n    }\n\n    this.props.onRequestClose('docClick', e);\n  };\n\n  Overlay.prototype.initSafeNode = function initSafeNode() {\n    var node = this.getWrapperNode && this.getWrapperNode() || _reactDom2['default'].findDOMNode(this),\n        safeNode = this.props.safeNode;\n\n    if (Array.isArray(safeNode)) {\n      safeNode.push(node);\n    } else {\n      safeNode = [node, safeNode];\n    }\n\n    this.addNodeForSafeClick(safeNode);\n  };\n\n  Overlay.prototype.addNodeForSafeClick = function addNodeForSafeClick(node) {\n    var _this6 = this;\n\n    if (Array.isArray(node)) {\n      node.forEach(function (n) {\n        _this6.addNodeForSafeClick(n);\n      });\n    } else {\n      var safeNode = this._getSafeNode(node);\n\n      if (safeNode && this._safeClickNode.indexOf(safeNode) === -1) {\n        this._safeClickNode.push(safeNode);\n      }\n    }\n  };\n\n  Overlay.prototype._onPosition = function _onPosition(res) {\n    if (this.state.visible) {\n      // 很可能我们访问不到contentNode节点，尤其当contentNode的ref为函数的时候\n      var contentNode = this.getContentNode();\n\n      if (contentNode) {\n        var align = res.align[0];\n        var className = contentNode.className.split(' ');\n        className.forEach(function (cls) {\n          if (cls.indexOf('position') > -1) {\n            _nextDom.classList.removeClass(contentNode, cls);\n          }\n        });\n\n        _nextDom.classList.addClass(contentNode, this.props.prefix + 'position-' + align);\n      }\n    }\n  };\n\n  return Overlay;\n}(_react2['default'].Component), _class.propTypes = {\n  /**\n   * 样式类名的品牌前缀\n   */\n  prefix: _propTypes2['default'].string,\n\n  /**\n   * 自定义类名\n   */\n  className: _propTypes2['default'].string,\n\n  /**\n   * 自定义样式对象\n   */\n  style: _propTypes2['default'].object,\n\n  /**\n   * 浮层内容\n   */\n  children: _propTypes2['default'].any,\n\n  /**\n   * 是否显示浮层, 如果此属性为false，浮层不会被渲染\n   */\n  visible: _propTypes2['default'].bool,\n\n  /**\n   * 是否支持esc按键关闭浮层\n   */\n  canCloseByEsc: _propTypes2['default'].bool,\n\n  /**\n   * 点击浮层外的区域是否关闭浮层\n   */\n  canCloseByOutSideClick: _propTypes2['default'].bool,\n\n  /**\n   * 点击遮罩区域是否关闭浮层\n   */\n  canCloseByMask: _propTypes2['default'].bool,\n\n  /**\n   * 配置动画的播放方式\n   * @param {String} in 进场动画\n   * @param {String} out 出场动画\n   */\n  animation: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].bool]),\n\n  /**\n   * 配置浮层定位的参照元素\n   */\n  target: _propTypes2['default'].any,\n\n  /**\n   * 浮层相对于target的定位, 详见开发指南的[定位部分](#定位)\n   */\n  align: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].bool]),\n\n  /**\n   * 浮层相对于target定位的微调\n   */\n  offset: _propTypes2['default'].array,\n\n  /**\n   * 浮层关闭前触发的事件\n   */\n  beforeClose: _propTypes2['default'].func,\n\n  /**\n   * 浮层关闭后触发的事件\n   */\n  onClose: _propTypes2['default'].func,\n\n  /**\n   * 浮层关闭后触发的事件, 如果有动画，则在动画结束后触发\n   */\n  afterClose: _propTypes2['default'].func,\n\n  /**\n   * 浮层打开前触发的事件\n   */\n  beforeOpen: _propTypes2['default'].func,\n\n  /**\n   * 浮层打开后触发的事件\n   */\n  onOpen: _propTypes2['default'].func,\n\n  /**\n   * 浮层打开后触发的事件, 如果有动画，则在动画结束后触发\n   */\n  afterOpen: _propTypes2['default'].func,\n\n  /**\n   * 浮层请求关闭触发的事件\n   * @param {String} reason 浮层关闭的来源\n   * @param {Event} e DOM事件\n   */\n  onRequestClose: _propTypes2['default'].func,\n\n  /**\n   * 浮层定位完成前触发的事件\n   */\n  beforePosition: _propTypes2['default'].func,\n\n  /**\n   * 浮层定位完成后触发的事件\n   * @param {Object} config 定位的参数\n   * @param {Object} node 定位的元素\n   */\n  onPosition: _propTypes2['default'].func,\n\n  /**\n   * 浮层打开的时候是否让里面的元素自动获取焦点\n   */\n  autoFocus: _propTypes2['default'].bool,\n\n  /**\n   * 是否显示遮罩\n   */\n  hasMask: _propTypes2['default'].bool,\n\n  /**\n   * 隐藏时是否保留子节点\n   */\n  cache: _propTypes2['default'].bool,\n  safeId: _propTypes2['default'].string,\n\n  /**\n   * 安全节点,当点击document的时候, 如果包含该节点则不会关闭浮层, 如果是函数需要返回ref, 如果是字符串则是该DOM的id, 也可以直接传入DOM节点\n   */\n  safeNode: _propTypes2['default'].any,\n\n  /**\n   * 浮层的根节点的样式类\n   */\n  wrapperClassName: _propTypes2['default'].string,\n\n  /**\n   * 指定渲染组件的容器\n   */\n  container: _propTypes2['default'].any,\n\n  /**\n   * 强制更新定位信息\n   */\n  shouldUpdatePosition: _propTypes2['default'].bool,\n\n  /**\n   * 是否自动调整定位的位置\n   */\n  needAdjust: _propTypes2['default'].bool,\n\n  /**\n   * 是否禁用页面滚动\n   */\n  disableScroll: _propTypes2['default'].bool\n}, _class.defaultProps = {\n  align: 'tl bl',\n  offset: [0, 0],\n  visible: false,\n  canCloseByEsc: true,\n  canCloseByOutSideClick: true,\n  canCloseByMask: true,\n  target: _position2['default'].VIEWPORT,\n  animation: {\n    'in': 'expandInDown',\n    out: 'expandOutUp'\n  },\n  afterClose: noop,\n  beforeClose: noop,\n  afterOpen: noop,\n  beforeOpen: noop,\n  onRequestClose: noop,\n  onOpen: noop,\n  onClose: noop,\n  onPosition: noop,\n  autoFocus: false,\n  hasMask: false,\n  prefix: 'next-',\n  cache: false,\n  safeId: null,\n  disableScroll: false\n}, _class.contextTypes = {\n  prefix: _propTypes2['default'].string\n}, _temp);\nOverlay.displayName = 'Overlay';\nexports['default'] = Overlay;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}