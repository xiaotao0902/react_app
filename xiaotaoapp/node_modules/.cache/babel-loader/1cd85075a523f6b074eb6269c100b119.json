{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _class, _temp;\n\nvar _css = require('./css.js');\n\nvar _css2 = _interopRequireDefault(_css);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar VIEWPORT = 'viewport'; // IE8 not support pageXOffset\n\nvar getPageX = function getPageX() {\n  return window.pageXOffset || document.documentElement.scrollLeft;\n};\n\nvar getPageY = function getPageY() {\n  return window.pageYOffset || document.documentElement.scrollTop;\n};\n\nvar getElementRect = function getElementRect(elem) {\n  var offsetTop = 0,\n      offsetLeft = 0,\n      offsetHeight = elem.offsetHeight,\n      offsetWidth = elem.offsetWidth;\n\n  do {\n    if (!isNaN(elem.offsetTop)) {\n      offsetTop += elem.offsetTop;\n    }\n\n    if (!isNaN(elem.offsetLeft)) {\n      offsetLeft += elem.offsetLeft;\n    }\n  } while ((elem = elem.offsetParent) !== null);\n\n  return {\n    top: offsetTop - (document.documentElement.scrollTop || document.body.scrollTop),\n    left: offsetLeft - (document.documentElement.scrollLeft || document.body.scrollLeft),\n    height: offsetHeight,\n    width: offsetWidth\n  };\n};\n\nvar Position = (_temp = _class = function () {\n  function Position(config) {\n    _classCallCheck(this, Position);\n\n    this.pinElement = config.pinElement;\n    this.baseElement = config.baseElement;\n    this.align = config.align || 'tl tl';\n    this.offset = config.offset || [0, 0];\n    this.needAdjust = config.needAdjust || false;\n    this.isRtl = config.isRtl || false;\n  }\n\n  Position.prototype.setPosition = function setPosition() {\n    var pinElement = this.pinElement;\n    var baseElement = this.baseElement;\n\n    var expectedAlign = this._getExpectedAlign();\n\n    var isPinFixed = void 0,\n        isBaseFixed = void 0,\n        firstPositionResult = void 0;\n\n    if (pinElement === VIEWPORT) {\n      return;\n    }\n\n    if (_css2['default'].get(pinElement, 'position') !== 'fixed') {\n      _css2['default'].set(pinElement, 'position', 'absolute');\n\n      isPinFixed = false;\n    } else {\n      isPinFixed = true;\n    }\n\n    if (baseElement === VIEWPORT || _css2['default'].get(baseElement, 'position') !== 'fixed') {\n      isBaseFixed = false;\n    } else {\n      isBaseFixed = true;\n    } // 根据期望的定位\n\n\n    for (var i = 0; i < expectedAlign.length; i++) {\n      var align = expectedAlign[i];\n\n      var pinElementPoints = this._normalizePosition(pinElement, align.split(' ')[0], isPinFixed);\n\n      var baseElementPoints = this._normalizePosition(baseElement, align.split(' ')[1], isPinFixed);\n\n      var pinElementParentOffset = this._getParentOffset(pinElement);\n\n      var baseElementOffset = isPinFixed && isBaseFixed ? this._getLeftTop(baseElement) : baseElementPoints.offset();\n      var top = baseElementOffset.top + baseElementPoints.y - pinElementParentOffset.top - pinElementPoints.y + this.offset[1];\n      var left = baseElementOffset.left + baseElementPoints.x - pinElementParentOffset.left - pinElementPoints.x + this.offset[0];\n\n      _css2['default'].set(pinElement, {\n        left: left + 'px',\n        top: top + 'px'\n      });\n\n      if (!firstPositionResult) {\n        firstPositionResult = {\n          left: left,\n          top: top\n        };\n      }\n\n      if (this._isInViewport(pinElement)) {\n        return align;\n      }\n    }\n\n    var inViewportLeft = this._makeElementInViewport(pinElement, firstPositionResult.left, 'Left', isPinFixed);\n\n    var inViewportTop = this._makeElementInViewport(pinElement, firstPositionResult.top, 'Top', isPinFixed);\n\n    _css2['default'].set(pinElement, {\n      left: inViewportLeft + 'px',\n      top: inViewportTop + 'px'\n    });\n\n    return expectedAlign[0];\n  };\n\n  Position.prototype._getParentOffset = function _getParentOffset(element) {\n    var parent = element.offsetParent || document.documentElement;\n    var offset = void 0;\n\n    if (parent === document.body && _css2['default'].get(parent, 'position') === 'static') {\n      offset = {\n        top: 0,\n        left: 0\n      };\n    } else {\n      offset = this._getElementOffset(parent);\n    }\n\n    offset.top += parseFloat(_css2['default'].get(parent, 'border-top-width'), 10);\n    offset.left += parseFloat(_css2['default'].get(parent, 'border-left-width'), 10);\n    return offset;\n  };\n\n  Position.prototype._makeElementInViewport = function _makeElementInViewport(pinElement, number, type, isPinFixed) {\n    var result = number,\n        docElement = document.documentElement,\n        offsetParent = pinElement.offsetParent || document.documentElement;\n\n    if (result < 0) {\n      if (isPinFixed) {\n        result = 0;\n      } else if (offsetParent === document.body && _css2['default'].get(offsetParent, 'position') === 'static') {\n        //Only when div's offsetParent is document.body, we set new position result.\n        result = Math.max(docElement['scroll' + type], document.body['scroll' + type]);\n      }\n    }\n\n    return result;\n  };\n\n  Position.prototype._normalizePosition = function _normalizePosition(element, align, isPinFixed) {\n    var points = this._normalizeElement(element, isPinFixed);\n\n    this._normalizeXY(points, align);\n\n    return points;\n  };\n\n  Position.prototype._normalizeXY = function _normalizeXY(points, align) {\n    var x = align.split('')[1];\n    var y = align.split('')[0];\n    points.x = this._xyConverter(x, points, 'width');\n    points.y = this._xyConverter(y, points, 'height');\n    return points;\n  };\n\n  Position.prototype._xyConverter = function _xyConverter(align, points, type) {\n    var res = align.replace(/t|l/gi, '0%').replace(/c/gi, '50%').replace(/b|r/gi, '100%').replace(/(\\d+)%/gi, function (m, d) {\n      return points.size()[type] * (d / 100);\n    });\n    return parseFloat(res, 10) || 0;\n  };\n\n  Position.prototype._getLeftTop = function _getLeftTop(element) {\n    return {\n      left: parseFloat(_css2['default'].get(element, 'left')) || 0,\n      top: parseFloat(_css2['default'].get(element, 'top')) || 0\n    };\n  };\n\n  Position.prototype._normalizeElement = function _normalizeElement(element, isPinFixed) {\n    var _this = this;\n\n    var result = {\n      element: element,\n      x: 0,\n      y: 0\n    },\n        isViewport = element === VIEWPORT,\n        docElement = document.documentElement;\n\n    result.offset = function () {\n      if (isPinFixed) {\n        return {\n          left: 0,\n          top: 0\n        };\n      } else if (isViewport) {\n        return {\n          left: getPageX(),\n          top: getPageY()\n        };\n      } else {\n        return _this._getElementOffset(element);\n      }\n    };\n\n    result.size = function () {\n      if (isViewport) {\n        return {\n          width: docElement.clientWidth,\n          height: docElement.clientHeight\n        };\n      } else {\n        return {\n          width: element.offsetWidth,\n          height: element.offsetHeight\n        };\n      }\n    };\n\n    return result;\n  };\n\n  Position.prototype._getElementOffset = function _getElementOffset(element) {\n    var rect = element.getBoundingClientRect();\n    var docElement = document.documentElement;\n    var body = document.body;\n    var docClientLeft = docElement.clientLeft || body.clientLeft || 0;\n    var docClientTop = docElement.clientTop || body.clientTop || 0;\n    return {\n      left: rect.left + (getPageX() - docClientLeft),\n      top: rect.top + (getPageY() - docClientTop)\n    };\n  }; // According to the location of the overflow to calculate the desired positioning\n\n\n  Position.prototype._getExpectedAlign = function _getExpectedAlign() {\n    var align = this.isRtl ? this._replaceAlignDir(this.align, /l|r/g, {\n      l: 'r',\n      r: 'l'\n    }) : this.align;\n    var expectedAlign = [align];\n\n    if (this.needAdjust) {\n      if (/t|b/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /t|b/g, {\n          t: 'b',\n          b: 't'\n        }));\n      }\n\n      if (/l|r/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /l|r/g, {\n          l: 'r',\n          r: 'l'\n        }));\n      }\n\n      if (/c/g.test(align)) {\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'l'\n        }));\n        expectedAlign.push(this._replaceAlignDir(align, /c(?= |$)/g, {\n          c: 'r'\n        }));\n      }\n\n      expectedAlign.push(this._replaceAlignDir(align, /l|r|t|b/g, {\n        l: 'r',\n        r: 'l',\n        t: 'b',\n        b: 't'\n      }));\n    }\n\n    return expectedAlign;\n  }; // Transform align order.\n\n\n  Position.prototype._replaceAlignDir = function _replaceAlignDir(align, regExp, map) {\n    return align.replace(regExp, function (res) {\n      return map[res];\n    });\n  }; // Detecting element is in the window， we want to adjust position later.\n\n\n  Position.prototype._isInViewport = function _isInViewport(element) {\n    var viewportSize = {\n      width: document.documentElement.clientWidth,\n      height: document.documentElement.clientHeight\n    }; //Avoid animate problem that use offsetWidth instead of getBoundingClientRect.\n\n    var elementRect = getElementRect(element);\n    return elementRect.left >= 0 && elementRect.left + element.offsetWidth <= viewportSize.width && elementRect.top >= 0 && elementRect.top + element.offsetHeight <= viewportSize.height;\n  };\n\n  return Position;\n}(), _class.VIEWPORT = VIEWPORT, _temp);\n\nPosition.place = function (pinElement, baseElement, align, offset, needAdjust, isRtl) {\n  return new Position({\n    pinElement: pinElement,\n    baseElement: baseElement,\n    align: align,\n    offset: offset,\n    needAdjust: needAdjust,\n    isRtl: isRtl\n  }).setPosition();\n};\n\nexports['default'] = Position;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}