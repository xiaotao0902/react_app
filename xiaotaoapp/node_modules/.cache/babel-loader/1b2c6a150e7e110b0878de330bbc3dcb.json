{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = undefined;\n\nvar _binaryReader = require('./binary-reader.js');\n\nvar _binaryReader2 = _interopRequireDefault(_binaryReader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar JPEGHeaders = function () {\n  function JPEGHeaders(data) {\n    _classCallCheck(this, JPEGHeaders);\n\n    var markers = {\n      0xFFE1: {\n        app: 'EXIF',\n        name: 'APP1',\n        signature: 'Exif\\0'\n      },\n      0xFFE2: {\n        app: 'ICC',\n        name: 'APP2',\n        signature: 'ICC_PROFILE\\0'\n      },\n      0xFFED: {\n        app: 'IPTC',\n        name: 'APP13',\n        signature: 'Photoshop 3.0\\0'\n      }\n    };\n    var headers = this.headers = [];\n    var read = void 0,\n        idx = void 0,\n        marker = void 0,\n        length = 0;\n    this.read = read = new _binaryReader2['default']();\n    read.init(data); // Check if data is jpeg\n\n    if (read.SHORT(0) !== 0xFFD8) {\n      return;\n    }\n\n    idx = 2;\n    var limit = Math.min(1048576, data.length);\n\n    while (idx <= limit) {\n      marker = read.SHORT(idx); // omit RST (restart) markers\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) {\n        idx += 2;\n        continue;\n      } // no headers allowed after SOS marker\n\n\n      if (marker === 0xFFDA || marker === 0xFFD9) {\n        break;\n      }\n\n      length = read.SHORT(idx + 2) + 2;\n\n      if (markers[marker] && read.STRING(idx + 4, markers[marker].signature.length) === markers[marker].signature) {\n        headers.push({\n          hex: marker,\n          app: markers[marker].app.toUpperCase(),\n          name: markers[marker].name.toUpperCase(),\n          start: idx,\n          length: length,\n          segment: read.SEGMENT(idx, length)\n        });\n      }\n\n      idx += length;\n    }\n\n    this.idx = idx;\n    read.init(null); // free memory\n  }\n\n  JPEGHeaders.prototype.restore = function restore(data) {\n    var headers = this.headers,\n        read = this.read;\n    read.init(data); // Check if data is jpeg\n\n    var jpegHeaders = new JPEGHeaders(data);\n\n    if (!jpegHeaders.headers) {\n      return false;\n    } // Delete any existing headers that need to be replaced\n\n\n    for (var i = jpegHeaders.headers.length; i > 0; i--) {\n      var hdr = jpegHeaders.headers[i - 1];\n      read.SEGMENT(hdr.start, hdr.length, '');\n    }\n\n    jpegHeaders.purge();\n    this.idx = read.SHORT(2) === 0xFFE0 ? 4 + read.SHORT(4) : 2;\n\n    for (var _i = 0, l = headers.length; _i < l; _i++) {\n      read.SEGMENT(this.idx, 0, headers[_i].segment);\n      this.idx += headers[_i].length;\n    }\n\n    return read.SEGMENT();\n  };\n\n  JPEGHeaders.prototype.get = function get(app) {\n    var headers = this.headers;\n    var array = [];\n\n    for (var i = 0, l = headers.length; i < l; i++) {\n      if (headers[i].app === app.toUpperCase()) {\n        array.push(headers[i].segment);\n      }\n    }\n\n    return array;\n  };\n\n  JPEGHeaders.prototype.set = function set(app, segment) {\n    var headers = this.headers;\n    var array = [];\n\n    if (typeof segment === 'string') {\n      array.push(segment);\n    } else {\n      array = segment;\n    }\n\n    for (var i = 0, j = 0, l = headers.length; i < l; i++) {\n      if (headers[i].app === app.toUpperCase()) {\n        headers[i].segment = array[j];\n        headers[i].length = array[j].length;\n        j++;\n      }\n\n      if (j >= array.length) {\n        break;\n      }\n    }\n  };\n\n  JPEGHeaders.prototype.purge = function purge() {\n    this.headers = [];\n    this.read.init(null);\n  };\n\n  return JPEGHeaders;\n}();\n\nexports['default'] = JPEGHeaders;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}