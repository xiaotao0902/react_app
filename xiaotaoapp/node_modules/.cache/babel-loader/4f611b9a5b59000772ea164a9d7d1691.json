{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _util = require('../util/index.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n} // TODO 1.x halfChecked => indeterminate\n\n/**\n * Tree\n */\n\n\nvar Tree = (_temp = _class = function (_Component) {\n  _inherits(Tree, _Component);\n\n  function Tree(props, context) {\n    _classCallCheck(this, Tree);\n\n    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));\n\n    ['onKeyDown', 'onCheck'].forEach(function (m) {\n      _this[m] = _this[m].bind(_this);\n    });\n    _this.checkedKeysChange = true;\n    _this.state = {\n      expandedKeys: _this.getDefaultExpandedKeys(props),\n      checkedKeys: _this.getDefaultCheckedKeys(props),\n      selectedKeys: _this.getDefaultSelectedKeys(props),\n      dragNodesKeys: '',\n      dragOverNodeKey: '',\n      dropNodeKey: ''\n    };\n    return _this;\n  }\n\n  Tree.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var expandedKeys = this.getDefaultExpandedKeys(nextProps, true);\n    var checkedKeys = this.getDefaultCheckedKeys(nextProps, true);\n    var selectedKeys = this.getDefaultSelectedKeys(nextProps, true);\n    var st = {};\n\n    if (expandedKeys) {\n      st.expandedKeys = expandedKeys;\n    }\n\n    if (checkedKeys) {\n      if (nextProps.checkedKeys === this.props.checkedKeys) {\n        this.checkedKeysChange = false;\n      } else {\n        this.checkedKeysChange = true;\n      }\n\n      st.checkedKeys = checkedKeys;\n    }\n\n    if (selectedKeys) {\n      st.selectedKeys = selectedKeys;\n    }\n\n    this.setState(st);\n  };\n\n  Tree.prototype.getPrefix = function getPrefix() {\n    return this.context.prefix || this.props.prefix;\n  };\n\n  Tree.prototype.onDragStart = function onDragStart(e, treeNode) {\n    this.dragNode = treeNode;\n    this.dragNodesKeys = this.getDragNodes(treeNode);\n    var st = {\n      dragNodesKeys: this.dragNodesKeys\n    };\n    var expandedKeys = this.getExpandedKeys(treeNode, false);\n\n    if (expandedKeys) {\n      this.getRawExpandedKeys();\n      st.expandedKeys = expandedKeys;\n    }\n\n    this.setState(st);\n    this.props.onDragStart({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onDragEnd = function onDragEnd() {\n    this.setState({\n      dragOverNodeKey: ''\n    });\n  };\n\n  Tree.prototype.onDragEnterGap = function onDragEnterGap(e, treeNode) {\n    var offsetTop = (0, _util.getOffset)(treeNode.refs.selectHandle).top;\n    var offsetHeight = treeNode.refs.selectHandle.offsetHeight;\n    var pageY = e.pageY;\n    var gapHeight = 2;\n\n    if (pageY > offsetTop + offsetHeight - gapHeight) {\n      this.dropPosition = 1;\n      return 1;\n    }\n\n    if (pageY < offsetTop + gapHeight - 1) {\n      this.dropPosition = -1;\n      return -1;\n    }\n\n    this.dropPosition = 0;\n    return 0;\n  };\n\n  Tree.prototype.onDragEnter = function onDragEnter(e, treeNode) {\n    var enterGap = this.onDragEnterGap(e, treeNode);\n\n    if (this.dragNode.props.eventKey === treeNode.props.eventKey && enterGap === 0) {\n      this.setState({\n        dragOverNodeKey: ''\n      });\n      return;\n    }\n\n    var st = {\n      dragOverNodeKey: treeNode.props.eventKey\n    };\n    var expandedKeys = this.getExpandedKeys(treeNode, true);\n\n    if (expandedKeys) {\n      this.getRawExpandedKeys();\n      st.expandedKeys = expandedKeys;\n    }\n\n    this.setState(st);\n    this.props.onDragEnter({\n      event: e,\n      node: treeNode,\n      expandedKeys: expandedKeys && [].concat(_toConsumableArray(expandedKeys)) || [].concat(_toConsumableArray(this.state.expandedKeys))\n    });\n  };\n\n  Tree.prototype.onDragOver = function onDragOver(e, treeNode) {\n    this.props.onDragOver({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onDragLeave = function onDragLeave(e, treeNode) {\n    this.props.onDragLeave({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onDrop = function onDrop(e, treeNode) {\n    var key = treeNode.props.eventKey;\n    this.setState({\n      dragOverNodeKey: '',\n      dropNodeKey: key\n    });\n\n    if (this.dragNodesKeys.indexOf(key) > -1) {\n      return false;\n    }\n\n    var res = _extends({\n      event: e\n    }, this.generateDropParams(treeNode));\n\n    if ('expandedKeys' in this.props) {\n      res.rawExpandedKeys = this._rawExpandedKeys && [].concat(_toConsumableArray(this._rawExpandedKeys)) || [].concat(_toConsumableArray(this.state.expandedKeys));\n    }\n\n    this.props.onDrop(res);\n  };\n\n  Tree.prototype.canDrop = function canDrop(treeNode) {\n    var params = this.generateDropParams(treeNode);\n    return this.props.canDrop(params);\n  };\n\n  Tree.prototype.generateDropParams = function generateDropParams(treeNode) {\n    var posArr = treeNode.props.pos.split('-');\n    return {\n      dragNode: this.dragNode,\n      dragNodesKeys: [].concat(_toConsumableArray(this.dragNodesKeys)),\n      node: treeNode,\n      dropPosition: this.dropPosition + Number(posArr[posArr.length - 1]),\n      dropToGap: this.dropPosition !== 0\n    };\n  };\n\n  Tree.prototype.onExpand = function onExpand(treeNode) {\n    var _this2 = this;\n\n    var expanded = !treeNode.props.expanded;\n    var controlled = 'expandedKeys' in this.props;\n    var expandedKeys = [].concat(_toConsumableArray(this.state.expandedKeys));\n    var index = expandedKeys.indexOf(treeNode.props.eventKey);\n\n    if (expanded && index === -1) {\n      expandedKeys.push(treeNode.props.eventKey);\n    } else if (!expanded && index > -1) {\n      expandedKeys.splice(index, 1);\n    }\n\n    if (!controlled) {\n      this.setState({\n        expandedKeys: expandedKeys\n      });\n    }\n\n    this.props.onExpand(expandedKeys, {\n      node: treeNode,\n      expanded: expanded\n    });\n\n    if (expanded && this.props.loadData) {\n      return this.props.loadData(treeNode).then(function () {\n        if (!controlled) {\n          _this2.setState({\n            expandedKeys: expandedKeys\n          });\n        }\n      });\n    }\n  };\n\n  Tree.prototype.onCheck = function onCheck(treeNode) {\n    var _this3 = this;\n\n    var checked = !treeNode.props.checked;\n\n    if (treeNode.props.halfChecked) {\n      checked = true;\n    }\n\n    var key = treeNode.props.eventKey;\n    var checkedKeys = [].concat(_toConsumableArray(this.state.checkedKeys));\n    var index = checkedKeys.indexOf(key);\n    var newSt = {\n      event: 'check',\n      node: treeNode,\n      checked: checked\n    };\n\n    if (this.props.checkStrictly && 'checkedKeys' in this.props) {\n      if (checked && index === -1) {\n        checkedKeys.push(key);\n      }\n\n      if (!checked && index > -1) {\n        checkedKeys.splice(index, 1);\n      }\n\n      newSt.checkedNodes = [];\n      (0, _util.loopAllChildren)(this.props.children, function (item, ind, pos, keyOrPos) {\n        if (checkedKeys.indexOf(keyOrPos) !== -1) {\n          newSt.checkedNodes.push(item);\n        }\n      });\n      this.props.onCheck((0, _util.getStrictlyValue)(checkedKeys, this.props.checkedKeys.halfChecked), newSt);\n    } else {\n      if (checked && index === -1) {\n        this.treeNodesStates[treeNode.props.pos].checked = true;\n        var checkedPositions = [];\n        Object.keys(this.treeNodesStates).forEach(function (i) {\n          if (_this3.treeNodesStates[i].checked) {\n            checkedPositions.push(i);\n          }\n        });\n        (0, _util.handleCheckState)(this.treeNodesStates, (0, _util.filterParentPosition)(checkedPositions), true);\n      }\n\n      if (!checked) {\n        this.treeNodesStates[treeNode.props.pos].checked = false;\n        this.treeNodesStates[treeNode.props.pos].halfChecked = false;\n        (0, _util.handleCheckState)(this.treeNodesStates, [treeNode.props.pos], false);\n      }\n\n      var checkKeys = (0, _util.getCheck)(this.treeNodesStates);\n      newSt.checkedNodes = checkKeys.checkedNodes;\n      newSt.checkedNodesPositions = checkKeys.checkedNodesPositions;\n      newSt.halfCheckedKeys = checkKeys.halfCheckedKeys;\n      this.checkKeys = checkKeys;\n      checkedKeys = checkKeys.checkedKeys;\n      this._checkedKeys = [].concat(_toConsumableArray(checkedKeys));\n\n      if (!('checkedKeys' in this.props)) {\n        this.setState({\n          checkedKeys: checkedKeys\n        });\n      }\n\n      this.props.onCheck(checkedKeys, newSt);\n    }\n  };\n\n  Tree.prototype.onSelect = function onSelect(treeNode) {\n    var props = this.props;\n    var selectedKeys = [].concat(_toConsumableArray(this.state.selectedKeys));\n    var eventKey = treeNode.props.eventKey;\n    var index = selectedKeys.indexOf(eventKey);\n    var selected = void 0;\n\n    if (index !== -1) {\n      selected = false;\n      selectedKeys.splice(index, 1);\n    } else {\n      selected = true;\n\n      if (!props.multiple) {\n        selectedKeys.length = 0;\n      }\n\n      selectedKeys.push(eventKey);\n    }\n\n    var selectedNodes = [];\n\n    if (selectedKeys.length) {\n      (0, _util.loopAllChildren)(this.props.children, function (item) {\n        if (selectedKeys.indexOf(item.key) !== -1) {\n          selectedNodes.push(item);\n        }\n      });\n    }\n\n    var newSt = {\n      event: 'select',\n      node: treeNode,\n      selected: selected,\n      selectedNodes: selectedNodes\n    };\n\n    if (!('selectedKeys' in this.props)) {\n      this.setState({\n        selectedKeys: selectedKeys\n      });\n    }\n\n    props.onSelect(selectedKeys, newSt);\n  };\n\n  Tree.prototype.onEditFinish = function onEditFinish(info) {\n    this.props.onEditFinish(info);\n  };\n\n  Tree.prototype.onMouseEnter = function onMouseEnter(e, treeNode) {\n    this.props.onMouseEnter({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onMouseLeave = function onMouseLeave(e, treeNode) {\n    this.props.onMouseLeave({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onContextMenu = function onContextMenu(e, treeNode) {\n    this.props.onRightClick({\n      event: e,\n      node: treeNode\n    });\n  };\n\n  Tree.prototype.onKeyDown = function onKeyDown(e) {\n    e.preventDefault();\n  };\n\n  Tree.prototype.getFilterExpandedKeys = function getFilterExpandedKeys(props, expandKeyProp, expandAll) {\n    var keys = props[expandKeyProp];\n    var expandedPositionArr = [];\n\n    if (props.autoExpandParent) {\n      (0, _util.loopAllChildren)(props.children, function (item, index, pos, newKey) {\n        if (keys.indexOf(newKey) > -1) {\n          expandedPositionArr.push(pos);\n        }\n      });\n    }\n\n    var filterExpandedKeys = [];\n    (0, _util.loopAllChildren)(props.children, function (item, index, pos, newKey) {\n      if (expandAll) {\n        filterExpandedKeys.push(newKey);\n      } else if (props.autoExpandParent) {\n        expandedPositionArr.forEach(function (p) {\n          if ((p.split('-').length > pos.split('-').length && (0, _util.isInclude)(pos.split('-'), p.split('-')) || pos === p) && filterExpandedKeys.indexOf(newKey) === -1) {\n            filterExpandedKeys.push(newKey);\n          }\n        });\n      }\n    });\n    return filterExpandedKeys.length ? filterExpandedKeys : keys;\n  };\n\n  Tree.prototype.getDefaultExpandedKeys = function getDefaultExpandedKeys(props, willReceiveProps) {\n    var expandedKeys = willReceiveProps ? undefined : this.getFilterExpandedKeys(props, 'defaultExpandedKeys', props.defaultExpandAll);\n\n    if ('expandedKeys' in props) {\n      expandedKeys = (props.autoExpandParent ? this.getFilterExpandedKeys(props, 'expandedKeys', false) : props.expandedKeys) || [];\n    }\n\n    return expandedKeys;\n  };\n\n  Tree.prototype.getDefaultCheckedKeys = function getDefaultCheckedKeys(props, willReceiveProps) {\n    var checkedKeys = willReceiveProps ? undefined : props.defaultCheckedKeys;\n\n    if ('checkedKeys' in props) {\n      checkedKeys = props.checkedKeys || [];\n\n      if (props.checkStrictly) {\n        if (props.checkedKeys.checked) {\n          checkedKeys = props.checkedKeys.checked;\n        } else if (!Array.isArray(props.checkedKeys)) {\n          checkedKeys = [];\n        }\n      }\n    }\n\n    return checkedKeys;\n  };\n\n  Tree.prototype.getDefaultSelectedKeys = function getDefaultSelectedKeys(props, willReceiveProps) {\n    var getKeys = function getKeys(keys) {\n      if (props.multiple) {\n        return [].concat(_toConsumableArray(keys));\n      }\n\n      if (keys.length) {\n        return [keys[0]];\n      }\n\n      return keys;\n    };\n\n    var selectedKeys = willReceiveProps ? undefined : getKeys(props.defaultSelectedKeys);\n\n    if ('selectedKeys' in props) {\n      selectedKeys = getKeys(props.selectedKeys);\n    }\n\n    return selectedKeys;\n  };\n\n  Tree.prototype.getRawExpandedKeys = function getRawExpandedKeys() {\n    if (!this._rawExpandedKeys && 'expandedKeys' in this.props) {\n      this._rawExpandedKeys = [].concat(_toConsumableArray(this.state.expandedKeys));\n    }\n  };\n\n  Tree.prototype.getDragNodes = function getDragNodes(treeNode) {\n    var dragNodesKeys = [];\n    var tPArr = treeNode.props.pos.split('-');\n    (0, _util.loopAllChildren)(this.props.children, function (item, index, pos, newKey) {\n      var pArr = pos.split('-');\n\n      if (treeNode.props.pos === pos || tPArr.length < pArr.length && (0, _util.isInclude)(tPArr, pArr)) {\n        dragNodesKeys.push(newKey);\n      }\n    });\n    return dragNodesKeys;\n  };\n\n  Tree.prototype.getExpandedKeys = function getExpandedKeys(treeNode, expand) {\n    var key = treeNode.props.eventKey;\n    var expandedKeys = this.state.expandedKeys;\n    var expandedIndex = expandedKeys.indexOf(key);\n    var exKeys = void 0;\n\n    if (expandedIndex > -1 && !expand) {\n      exKeys = [].concat(_toConsumableArray(expandedKeys));\n      exKeys.splice(expandedIndex, 1);\n      return exKeys;\n    }\n\n    if (expand && expandedKeys.indexOf(key) === -1) {\n      return expandedKeys.concat([key]);\n    }\n  };\n\n  Tree.prototype.filterTreeNode = function filterTreeNode(treeNode) {\n    var filterTreeNode = this.props.filterTreeNode;\n\n    if (typeof filterTreeNode !== 'function' || treeNode.props.disabled) {\n      return false;\n    }\n\n    return filterTreeNode.call(this, treeNode);\n  };\n\n  Tree.prototype.renderTreeNode = function renderTreeNode(child, index) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var pos = level + '-' + index;\n    var key = child.key || pos;\n    var state = this.state;\n    var props = this.props;\n    var selectable = props.selectable;\n    var editable = props.editable;\n    var draggable = props.draggable;\n\n    if (child.props.hasOwnProperty('selectable')) {\n      selectable = child.props.selectable;\n    }\n\n    if (child.props.hasOwnProperty('editable')) {\n      editable = child.props.editable;\n    }\n\n    if (child.props.hasOwnProperty('draggable')) {\n      draggable = child.props.draggable;\n    }\n\n    var cloneProps = {\n      ref: 'treeNode-' + key,\n      root: this,\n      eventKey: key,\n      pos: pos,\n      selectable: selectable,\n      editable: editable,\n      loadData: props.loadData,\n      onMouseEnter: props.onMouseEnter,\n      onMouseLeave: props.onMouseLeave,\n      onRightClick: props.onRightClick,\n      prefix: this.getPrefix(),\n      showLine: props.showLine,\n      showIcon: props.showIcon,\n      draggable: draggable,\n      dragOver: state.dragOverNodeKey === key && this.dropPosition === 0,\n      dragOverGapTop: state.dragOverNodeKey === key && this.dropPosition === -1,\n      dragOverGapBottom: state.dragOverNodeKey === key && this.dropPosition === 1,\n      expanded: state.expandedKeys.indexOf(key) !== -1,\n      selected: state.selectedKeys.indexOf(key) !== -1,\n      filterTreeNode: this.filterTreeNode.bind(this)\n    };\n\n    if (props.checkable) {\n      cloneProps.checkable = _react2['default'].createElement('span', {\n        className: 'next-tree-checkbox-inner'\n      });\n\n      if (props.checkStrictly) {\n        if (state.checkedKeys) {\n          cloneProps.checked = state.checkedKeys.indexOf(key) !== -1 || false;\n        }\n\n        if (props.checkedKeys.halfChecked) {\n          cloneProps.halfChecked = props.checkedKeys.halfChecked.indexOf(key) !== -1 || false;\n        } else {\n          cloneProps.halfChecked = false;\n        }\n      } else {\n        if (this.checkedKeys) {\n          cloneProps.checked = this.checkedKeys.indexOf(key) !== -1 || false;\n        }\n\n        cloneProps.halfChecked = this.halfCheckedKeys.indexOf(key) !== -1;\n      }\n\n      if (this.treeNodesStates[pos]) {\n        cloneProps = _extends({}, cloneProps, this.treeNodesStates[pos].siblingPosition);\n      }\n    }\n\n    return _react2['default'].cloneElement(child, cloneProps);\n  };\n\n  Tree.prototype.render = function render() {\n    var _classNames,\n        _this4 = this;\n\n    var prefix = this.getPrefix(); // eslint-disable-next-line\n\n    var _props = this.props,\n        propsPrefix = _props.prefix,\n        className = _props.className,\n        focusable = _props.focusable,\n        checkable = _props.checkable,\n        loadData = _props.loadData,\n        showLine = _props.showLine,\n        checkStrictly = _props.checkStrictly,\n        children = _props.children,\n        _treeNodesStates = _props._treeNodesStates,\n        enableCheckedCache = _props.enableCheckedCache,\n        draggable = _props.draggable;\n    var domProps = {\n      className: (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefix + 'tree', true), _defineProperty(_classNames, prefix + 'tree-with-line', showLine), _defineProperty(_classNames, prefix + 'tree-draggable', draggable), _defineProperty(_classNames, className, className), _classNames)),\n      role: 'tree-node'\n    };\n\n    if (focusable) {\n      domProps.tabIndex = '0';\n      domProps.onKeyDown = this.onKeyDown;\n    }\n\n    if (checkable && (this.checkedKeysChange || loadData || !enableCheckedCache)) {\n      if (checkStrictly) {\n        this.treeNodesStates = {};\n        (0, _util.loopAllChildren)(children, function (item, index, pos, keyOrPos, siblingPosition) {\n          _this4.treeNodesStates[pos] = {\n            siblingPosition: siblingPosition\n          };\n        });\n      } else if (_treeNodesStates) {\n        this.treeNodesStates = _treeNodesStates.treeNodesStates;\n        this.halfCheckedKeys = _treeNodesStates.halfCheckedKeys;\n        this.checkedKeys = _treeNodesStates.checkedKeys;\n      } else {\n        var checkedKeys = this.state.checkedKeys;\n        var checkKeys = void 0;\n\n        if (enableCheckedCache && !loadData && this.checkKeys && this._checkedKeys && (0, _util.arraysEqual)(this._checkedKeys, checkedKeys)) {\n          checkKeys = this.checkKeys;\n        } else {\n          var checkedPositions = [];\n          this.treeNodesStates = {};\n          (0, _util.loopAllChildren)(children, function (item, index, pos, keyOrPos, siblingPosition) {\n            _this4.treeNodesStates[pos] = {\n              node: item,\n              key: keyOrPos,\n              checked: false,\n              halfChecked: false,\n              siblingPosition: siblingPosition\n            };\n\n            if (checkedKeys.indexOf(keyOrPos) !== -1) {\n              _this4.treeNodesStates[pos].checked = true;\n              checkedPositions.push(pos);\n            }\n          });\n          (0, _util.handleCheckState)(this.treeNodesStates, (0, _util.filterParentPosition)(checkedPositions), true);\n          checkKeys = (0, _util.getCheck)(this.treeNodesStates);\n        }\n\n        this.halfCheckedKeys = checkKeys.halfCheckedKeys;\n        this.checkedKeys = checkKeys.checkedKeys;\n      }\n    }\n\n    return _react2['default'].createElement('ul', _extends({}, domProps, {\n      ref: 'tree'\n    }), _react2['default'].Children.map(children, function (child, index) {\n      return _this4.renderTreeNode(child, index);\n    }));\n  };\n\n  return Tree;\n}(_react.Component), _class.contextTypes = {\n  prefix: _propTypes2['default'].string\n}, _class.propTypes = {\n  /**\n   * 样式类名的品牌前缀\n   */\n  prefix: _propTypes2['default'].string,\n\n  /**\n   * 自定义类名\n   */\n  className: _propTypes2['default'].string,\n\n  /**\n   * 自定义内联样式\n   */\n  style: _propTypes2['default'].object,\n\n  /**\n   * 树节点\n   */\n  children: _propTypes2['default'].node,\n\n  /**\n   * 是否显示树的线\n   */\n  showLine: _propTypes2['default'].bool,\n\n  /**\n   * 是否支持选中节点\n   */\n  selectable: _propTypes2['default'].bool,\n\n  /**\n   * （用于受控）当前选中节点key的数组\n   */\n  selectedKeys: _propTypes2['default'].arrayOf(_propTypes2['default'].string),\n\n  /**\n   * （用于非受控）默认选中节点key的数组\n   */\n  defaultSelectedKeys: _propTypes2['default'].arrayOf(_propTypes2['default'].string),\n\n  /**\n   * 选中或取消选中节点时触发的回调函数\n   * @param {Array} selectedKeys 选中节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {Array} extra.selectedNodes 选中节点的数组\n   * @param {ReactElement} extra.node 当前操作的节点\n   * @param {Boolean} extra.selected 当前操作是否是选中\n   * @param {String} extra.event 当前操作的类型，值为'select'\n   */\n  onSelect: _propTypes2['default'].func,\n\n  /**\n   * 是否支持多选\n   */\n  multiple: _propTypes2['default'].bool,\n\n  /**\n   * 是否支持勾选节点的复选框\n   */\n  checkable: _propTypes2['default'].bool,\n\n  /**\n   * （用于受控）当前勾选复选框节点key的数组或`{checked: Array, halfChecked: Array}`的对象\n   */\n  checkedKeys: _propTypes2['default'].oneOfType([_propTypes2['default'].arrayOf(_propTypes2['default'].string), _propTypes2['default'].object]),\n\n  /**\n   * （用于非受控）默认勾选复选框节点key的数组\n   */\n  defaultCheckedKeys: _propTypes2['default'].arrayOf(_propTypes2['default'].string),\n\n  /**\n   * 勾选节点复选框是否完全受控（父子节点选中状态不再关联）\n   */\n  checkStrictly: _propTypes2['default'].bool,\n\n  /**\n   * 是否启用勾选节点复选框的缓存来提高性能，如果dataSource需要被动态更新，请将其设置为false\n   */\n  enableCheckedCache: _propTypes2['default'].bool,\n\n  /**\n   * 勾选或取消勾选复选框时触发的回调函数\n   * @param {Array} checkedKeys 勾选复选框节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {Array} extra.checkedNodes 勾选复选框节点的数组\n   * @param {Array} extra.checkedNodesPositions 包含有勾选复选框节点和其位置的对象的数组\n   * @param {Array} extra.halfCheckedKeys 半选复选框节点key的数组\n   * @param {ReactElement} extra.node 当前操作的节点\n   * @param {Boolean} extra.checked 当前操作是否是勾选\n   * @param {String} extra.event 当前操作的类型，值为'check'\n   */\n  onCheck: _propTypes2['default'].func,\n\n  /**\n   * （用于受控）当前展开的节点key的数组\n   */\n  expandedKeys: _propTypes2['default'].arrayOf(_propTypes2['default'].string),\n\n  /**\n   * （用于非受控）默认展开的节点key的数组\n   */\n  defaultExpandedKeys: _propTypes2['default'].arrayOf(_propTypes2['default'].string),\n\n  /**\n   * 是否默认展开所有节点\n   */\n  defaultExpandAll: _propTypes2['default'].bool,\n\n  /**\n   * 是否自动展开父节点\n   */\n  autoExpandParent: _propTypes2['default'].bool,\n\n  /**\n   * 展开或收起节点时触发的回调函数\n   * @param {Array} expandedKeys 展开的节点key的数组\n   * @param {Object} extra 额外参数\n   * @param {ReactElement} extra.node 当前操作的节点\n   * @param {Boolean} extra.expanded 当前操作是否是展开\n   */\n  onExpand: _propTypes2['default'].func,\n\n  /**\n   * 是否支持编辑节点内容\n   */\n  editable: _propTypes2['default'].bool,\n\n  /**\n   * 编辑节点内容完成时触发的回调函数\n   * @param {String} key 编辑节点的key\n   * @param {String} label 编辑节点完成时节点的文本\n   */\n  onEditFinish: _propTypes2['default'].func,\n\n  /**\n   * 是否支持拖拽节点\n   */\n  draggable: _propTypes2['default'].bool,\n\n  /**\n   * 开始拖拽节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {ReactElement} info.node 拖拽的节点\n   */\n  onDragStart: _propTypes2['default'].func,\n\n  /**\n   * 拖拽节点进入目标节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {ReactElement} info.node 目标节点\n   * @param {Array} info.expandedKeys 当前展开的节点key的数组\n   */\n  onDragEnter: _propTypes2['default'].func,\n\n  /**\n   * 拖拽节点在目标节点上移动的时候触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {ReactElement} info.node 目标节点\n   */\n  onDragOver: _propTypes2['default'].func,\n\n  /**\n   * 拖拽节点离开目标节点时触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {ReactElement} info.node 目标节点\n   */\n  onDragLeave: _propTypes2['default'].func,\n\n  /**\n   * 拖拽节点放入目标节点内或前后触发的回调函数\n   * @param {Object} info 拖拽信息\n   * @param {Object} info.event 事件对象\n   * @param {ReactElement} info.node 目标节点\n   * @param {ReactElement} info.dragNode 拖拽的节点\n   * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点key的数组\n   * @param {Number} info.dropPosition 拖拽的节点在拖拽后被放置在当前层级的位置\n   * @param {Boolean} info.dropToGap 是否被放置在目标节点的前后（没有被放置在目标节点内部）\n   */\n  onDrop: _propTypes2['default'].func,\n\n  /**\n   * 节点是否可被作为拖拽的目标节点\n   * @param {Object} info 拖拽信息\n   * @param {ReactElement} info.node 目标节点\n   * @param {ReactElement} info.dragNode 拖拽的节点\n   * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点key的数组\n   * @param {Number} info.dropPosition 拖拽的节点在拖拽后被放置在当前层级的位置\n   * @param {Boolean} info.dropToGap 是否被放置在目标节点的前后（没有被放置在目标节点内部）\n   * @return {Boolean} 是否可以被当作目标节点\n   */\n  canDrop: _propTypes2['default'].func,\n\n  /**\n   * 异步加载数据的函数\n   * @param {ReactElement} node 被点击展开的节点\n   */\n  loadData: _propTypes2['default'].func,\n\n  /**\n   * 按需筛选高亮节点\n   * @param {ReactElement} node 待筛选的节点\n   * @return {Boolean} 是否被筛选中\n   */\n  filterTreeNode: _propTypes2['default'].func,\n\n  /**\n   * 右键点击节点时触发的回调函数\n   * @param {Object} event 事件对象\n   * @param {ReactElement} node 点击的节点\n   */\n  onRightClick: _propTypes2['default'].func,\n\n  /**\n   * 设置节点是否占满剩余空间，一般用于统一在各节点右侧添加元素(借助flex实现，暂时只支持ie10+)\n   */\n  isLabelBlock: _propTypes2['default'].bool,\n\n  /**\n   * 是否开启展开收起动画\n   */\n  animation: _propTypes2['default'].bool,\n  showIcon: _propTypes2['default'].bool,\n  _treeNodesStates: _propTypes2['default'].object,\n  onMouseEnter: _propTypes2['default'].func,\n  onMouseLeave: _propTypes2['default'].func\n}, _class.defaultProps = {\n  prefix: 'next-',\n  showLine: false,\n  showIcon: false,\n  selectable: true,\n  editable: false,\n  multiple: false,\n  checkable: false,\n  checkStrictly: false,\n  enableCheckedCache: true,\n  draggable: false,\n  autoExpandParent: true,\n  defaultExpandAll: false,\n  defaultExpandedKeys: [],\n  defaultCheckedKeys: [],\n  defaultSelectedKeys: [],\n  onExpand: function onExpand() {},\n  onCheck: function onCheck() {},\n  onSelect: function onSelect() {},\n  onDragStart: function onDragStart() {},\n  onDragEnter: function onDragEnter() {},\n  onDragOver: function onDragOver() {},\n  onDragLeave: function onDragLeave() {},\n  onDrop: function onDrop() {},\n  canDrop: function canDrop() {\n    return true;\n  },\n  onEditFinish: function onEditFinish() {},\n  isLabelBlock: false,\n  animation: true\n}, _temp);\nTree.displayName = 'Tree';\nexports['default'] = Tree;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}