{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp, _class2, _temp2, _class3, _temp3;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactDom = require('react-dom');\n\nvar _TransitionGroup = require('react-transition-group/TransitionGroup');\n\nvar _TransitionGroup2 = _interopRequireDefault(_TransitionGroup);\n\nvar _nextUtil = require('../../next-util/lib/index.js');\n\nvar _nextDom = require('../../next-dom/lib/index.js');\n\nvar _names = require('./names.js');\n\nvar _names2 = _interopRequireDefault(_names);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n}\n\nvar noop = function noop() {};\n\nvar on = _nextDom.events.on;\nvar addClass = _nextDom.classList.addClass;\nvar removeClass = _nextDom.classList.removeClass;\nvar AnimateChild = (_temp = _class = function (_React$Component) {\n  _inherits(AnimateChild, _React$Component);\n\n  function AnimateChild() {\n    _classCallCheck(this, AnimateChild);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  AnimateChild.prototype.componentDidMount = function componentDidMount() {\n    this.node = (0, _reactDom.findDOMNode)(this);\n    this.onAnimateEnd = this.onAnimateEnd.bind(this);\n\n    if (this.props.useTransition && _nextUtil.support.transition) {\n      this._animation = on(this.node, _nextUtil.support.transition.end, this.onAnimateEnd);\n    } else if (_nextUtil.support.animation) {\n      this._animation = on(this.node, _nextUtil.support.animation.end, this.onAnimateEnd);\n    }\n  };\n\n  AnimateChild.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.node !== (0, _reactDom.findDOMNode)(this)) {\n      if (this._animation && this._animation.off) {\n        this._animation.off();\n      }\n\n      this.componentDidMount();\n    }\n  };\n\n  AnimateChild.prototype.fakeAnimationEvent = function fakeAnimationEvent() {\n    if (!_nextUtil.support.animation || this.props.useTransition && !_nextUtil.support.transition) {\n      this.timeoutEnd = setTimeout(this.onAnimateEnd, 10);\n    }\n  };\n\n  AnimateChild.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._animation && this._animation.off) {\n      this._animation.off();\n    }\n\n    clearTimeout(this.timeoutEnd);\n  };\n\n  AnimateChild.prototype.componentWillAppear = function componentWillAppear(done) {\n    if (this.props.animationAppear) {\n      this.playAction('appear', done);\n    } else {\n      done();\n    }\n\n    this.props.beforeAppear();\n    this.fakeAnimationEvent();\n  };\n\n  AnimateChild.prototype.componentDidAppear = function componentDidAppear() {\n    this.props.afterAppear();\n  };\n\n  AnimateChild.prototype.componentWillEnter = function componentWillEnter(done) {\n    this.playAction('enter', done);\n    this.props.beforeEnter();\n    this.fakeAnimationEvent();\n  };\n\n  AnimateChild.prototype.componentDidEnter = function componentDidEnter() {\n    this.props.afterEnter();\n  };\n\n  AnimateChild.prototype.componentWillLeave = function componentWillLeave(done) {\n    this.playAction('leave', done);\n    this.props.beforeLeave();\n    this.fakeAnimationEvent();\n  };\n\n  AnimateChild.prototype.componentDidLeave = function componentDidLeave() {\n    this.props.afterLeave();\n  };\n\n  AnimateChild.prototype.onAnimateEnd = function onAnimateEnd(e) {\n    if (e && e.target !== this.node) {\n      return;\n    }\n\n    clearTimeout(this.timeout);\n\n    if (this._done) {\n      this._done();\n    }\n\n    e && e.stopPropagation();\n  };\n\n  AnimateChild.prototype.playAction = function playAction(type, done) {\n    var node = (0, _reactDom.findDOMNode)(this),\n        animation = this.props.animation,\n        res = animation[type];\n\n    if (typeof res === 'string') {\n      Object.keys(animation).forEach(function (key) {\n        if (typeof animation[key] === 'string') {\n          removeClass(node, animation[key]);\n          removeClass(node, animation[key] + '-active');\n        }\n      });\n      addClass(node, res);\n      this.addActiveClass(node, res + '-active');\n      this._done = done;\n    } else if (typeof res === 'function') {\n      res(node, done);\n    } else {\n      done();\n    }\n\n    this.node = node;\n  };\n\n  AnimateChild.prototype.addActiveClass = function addActiveClass(node, className) {\n    this.timeout = setTimeout(function () {\n      addClass(node, className);\n    }, 20);\n  };\n\n  AnimateChild.prototype.render = function render() {\n    return this.props.children;\n  };\n\n  return AnimateChild;\n}(_react2['default'].Component), _class.propTypes = {\n  beforeAppear: _propTypes2['default'].func,\n  afterAppear: _propTypes2['default'].func,\n  beforeEnter: _propTypes2['default'].func,\n  afterEnter: _propTypes2['default'].func,\n  beforeLeave: _propTypes2['default'].func,\n  afterLeave: _propTypes2['default'].func,\n  children: _propTypes2['default'].any,\n  useTransition: _propTypes2['default'].bool,\n  animationAppear: _propTypes2['default'].bool\n}, _class.defaultProps = {\n  animationAppear: true\n}, _temp);\n/* eslint-disable react/no-multi-comp*/\n\nAnimateChild.displayName = 'AnimateChild';\nvar SingeChildWrapper = (_temp2 = _class2 = function (_React$Component2) {\n  _inherits(SingeChildWrapper, _React$Component2);\n\n  function SingeChildWrapper() {\n    _classCallCheck(this, SingeChildWrapper);\n\n    return _possibleConstructorReturn(this, _React$Component2.apply(this, arguments));\n  }\n\n  SingeChildWrapper.prototype.render = function render() {\n    var children = _react2['default'].Children.toArray(this.props.children);\n\n    return children[0] || null;\n  };\n\n  return SingeChildWrapper;\n}(_react2['default'].Component), _class2.propTypes = {\n  children: _propTypes2['default'].any\n}, _temp2);\n/**\n * Animate\n */\n\nSingeChildWrapper.displayName = 'SingeChildWrapper';\nvar Animate = (_temp3 = _class3 = function (_React$Component3) {\n  _inherits(Animate, _React$Component3);\n\n  function Animate() {\n    _classCallCheck(this, Animate);\n\n    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));\n  }\n\n  Animate.prototype.render = function render() {\n    var _props = this.props,\n        animation = _props.animation,\n        children = _props.children,\n        component = _props.component,\n        animationAppear = _props.animationAppear,\n        afterAppear = _props.afterAppear,\n        afterEnter = _props.afterEnter,\n        afterLeave = _props.afterLeave,\n        singleMode = _props.singleMode,\n        useTransition = _props.useTransition,\n        beforeAppear = _props.beforeAppear,\n        beforeEnter = _props.beforeEnter,\n        beforeLeave = _props.beforeLeave,\n        others = _objectWithoutProperties(_props, ['animation', 'children', 'component', 'animationAppear', 'afterAppear', 'afterEnter', 'afterLeave', 'singleMode', 'useTransition', 'beforeAppear', 'beforeEnter', 'beforeLeave']),\n        attrs = {\n      afterAppear: afterAppear,\n      afterEnter: afterEnter,\n      afterLeave: afterLeave,\n      beforeAppear: beforeAppear,\n      beforeEnter: beforeEnter,\n      beforeLeave: beforeLeave,\n      animationAppear: animationAppear,\n      animation: this.normalizeAnimation(animation)\n    },\n        length = _react2['default'].Children.count(children),\n        animateChildren = _react2['default'].Children.map(children, function (child, index) {\n      var key = child.key;\n\n      if (!key) {\n        key = 'animate-' + index;\n      }\n\n      return _react2['default'].createElement(AnimateChild, _extends({}, attrs, {\n        key: key,\n        useTransition: useTransition\n      }), child);\n    });\n\n    if (!component && length <= 1 && singleMode) {\n      component = SingeChildWrapper;\n    }\n\n    return _react2['default'].createElement(_TransitionGroup2['default'], _extends({\n      component: component\n    }, others), animateChildren);\n  };\n\n  Animate.prototype.normalizeAnimation = function normalizeAnimation(animation) {\n    if (typeof animation === 'string') {\n      return {\n        appear: animation + '-appear',\n        enter: animation + '-enter',\n        leave: animation + '-leave'\n      };\n    }\n\n    return animation;\n  };\n\n  return Animate;\n}(_react2['default'].Component), _class3.propTypes = {\n  children: _propTypes2['default'].any,\n\n  /**\n  * 配置动画的播放方式, 详见[animation](#animation)\n  */\n  animation: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].object]),\n  beforeAppear: _propTypes2['default'].func,\n\n  /**\n  * 在初始动画播放完毕触发的事件\n  */\n  afterAppear: _propTypes2['default'].func,\n  beforeEnter: _propTypes2['default'].func,\n\n  /**\n  * 在进场动画播放完毕触发的事件\n  */\n  afterEnter: _propTypes2['default'].func,\n  beforeLeave: _propTypes2['default'].func,\n\n  /**\n  * 在离开动画播放完毕触发的事件\n  */\n  afterLeave: _propTypes2['default'].func,\n\n  /**\n  * 在针对多个子节点播放动画的时候包裹的标签\n  */\n  component: _propTypes2['default'].any,\n\n  /**\n  * 是否是有单个节点，如果有多个动画的孩子节点，设置该选项为false\n  */\n  singleMode: _propTypes2['default'].bool,\n  useTransition: _propTypes2['default'].bool,\n\n  /**\n  * 是否在初始的时候播放动画\n  */\n  animationAppear: _propTypes2['default'].bool\n}, _class3.defaultProps = {\n  animation: {\n    appear: noop,\n    enter: noop,\n    leave: noop\n  },\n  beforeAppear: noop,\n  afterAppear: noop,\n  beforeEnter: noop,\n  afterEnter: noop,\n  beforeLeave: noop,\n  afterLeave: noop,\n  singleMode: true,\n  animationAppear: true,\n  useTransition: false\n}, _temp3);\nAnimate.displayName = 'Animate';\nexports['default'] = Animate;\nAnimate.names = _names2['default'];\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}