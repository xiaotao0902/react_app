{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _trackHelper = require('./trackHelper.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar helpers = {\n  initialize: function initialize(props) {\n    var _this = this;\n\n    var retsetSlide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var slickList = _reactDom2['default'].findDOMNode(this.list);\n\n    var slideCount = _react2['default'].Children.count(props.children);\n\n    var listWidth = this.getWidth(slickList);\n    var trackWidth = this.getWidth(_reactDom2['default'].findDOMNode(this.track));\n    var slideWidth = void 0;\n\n    if (!props.vertical) {\n      var centerPaddingAdj = props.centerMode && parseInt(props.centerPadding) * 2;\n      slideWidth = (listWidth - centerPaddingAdj) / props.slidesToShow;\n    } else {\n      slideWidth = listWidth;\n    }\n\n    var slideHeight = this.getHeight(slickList.querySelector('[data-index=\"0\"]'));\n    var listHeight = slideHeight * props.slidesToShow;\n    var currentSlide = void 0;\n\n    if (retsetSlide) {\n      currentSlide = props.rtl ? slideCount - 1 - props.initialSlide : props.initialSlide;\n    } else {\n      currentSlide = this.state.currentSlide;\n    }\n\n    this.setState({\n      slideCount: slideCount,\n      slideWidth: slideWidth,\n      listWidth: listWidth,\n      trackWidth: trackWidth,\n      currentSlide: currentSlide,\n      slideHeight: slideHeight,\n      listHeight: listHeight\n    }, function () {\n      var targetLeft = (0, _trackHelper.getTrackLeft)(_extends({\n        slideIndex: _this.state.currentSlide,\n        trackRef: _this.track\n      }, props, _this.state)); // getCSS function needs previously set state\n\n      var trackStyle = (0, _trackHelper.getTrackCSS)(_extends({\n        left: targetLeft\n      }, props, _this.state));\n\n      _this.setState({\n        trackStyle: trackStyle\n      });\n\n      _this.autoPlay(); // once we're set up, trigger the initial autoplay.\n\n    });\n  },\n  update: function update(props) {\n    var retsetSlide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.initialize(props, retsetSlide);\n  },\n  getWidth: function getWidth(elem) {\n    return elem.getBoundingClientRect().width || elem.offsetWidth;\n  },\n  getHeight: function getHeight(elem) {\n    return elem.getBoundingClientRect().height || elem.offsetHeight;\n  },\n  adaptHeight: function adaptHeight() {\n    if (this.props.adaptiveHeight) {\n      var selector = '[data-index=\"' + this.state.currentSlide + '\"]';\n\n      if (this.list) {\n        var slickList = _reactDom2['default'].findDOMNode(this.list);\n\n        var listHeight = slickList.querySelector(selector).offsetHeight;\n        slickList.style.height = listHeight + 'px';\n      }\n    }\n  },\n  canGoNext: function canGoNext(opts) {\n    var canGo = true;\n\n    if (!opts.infinite) {\n      if (opts.centerMode) {\n        if (opts.currentSlide >= opts.slideCount - 1) {\n          canGo = false;\n        }\n      } else if (opts.slideCount <= opts.slidesToShow || opts.currentSlide >= opts.slideCount - opts.slidesToShow) {\n        // check if all slides are shown in slider\n        canGo = false;\n      }\n    }\n\n    return canGo;\n  },\n  slideHandler: function slideHandler(index) {\n    var _this2 = this; // Functionality of animateSlide and postSlide is merged into this function\n\n\n    var targetSlide = void 0,\n        currentSlide = void 0;\n    var callback = void 0;\n\n    if (this.props.waitForAnimate && this.state.animating) {\n      return;\n    }\n\n    if (this.props.fade) {\n      currentSlide = this.state.currentSlide; // don't change slide if it's not infinite and current slide is the first or last slide'\n\n      if (this.props.infinite === false && (index < 0 || index >= this.state.slideCount)) {\n        return;\n      } //  Shifting targetSlide back into the range\n\n\n      if (index < 0) {\n        targetSlide = index + this.state.slideCount;\n      } else if (index >= this.state.slideCount) {\n        targetSlide = index - this.state.slideCount;\n      } else {\n        targetSlide = index;\n      }\n\n      if (this.props.lazyLoad && this.state.lazyLoadedList.indexOf(targetSlide) < 0) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(targetSlide)\n        });\n      }\n\n      callback = function callback() {\n        _this2.setState({\n          animating: false\n        });\n\n        if (_this2.props.afterChange) {\n          _this2.props.afterChange(targetSlide);\n        }\n\n        delete _this2.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: targetSlide\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed);\n      });\n\n      if (this.props.beforeChange) {\n        this.props.beforeChange(this.state.currentSlide, targetSlide);\n      }\n\n      this.autoPlay();\n      return;\n    }\n\n    targetSlide = index;\n\n    if (targetSlide < 0) {\n      if (this.props.infinite === false) {\n        currentSlide = 0;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = this.state.slideCount - this.state.slideCount % this.props.slidesToScroll;\n      } else {\n        currentSlide = this.state.slideCount + targetSlide;\n      }\n    } else if (targetSlide >= this.state.slideCount) {\n      if (this.props.infinite === false) {\n        currentSlide = this.state.slideCount - this.props.slidesToShow;\n      } else if (this.state.slideCount % this.props.slidesToScroll !== 0) {\n        currentSlide = 0;\n      } else {\n        currentSlide = targetSlide - this.state.slideCount;\n      }\n    } else {\n      currentSlide = targetSlide;\n    }\n\n    var targetLeft = (0, _trackHelper.getTrackLeft)(_extends({\n      slideIndex: targetSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    var currentLeft = (0, _trackHelper.getTrackLeft)(_extends({\n      slideIndex: currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n\n    if (this.props.infinite === false) {\n      targetLeft = currentLeft;\n    }\n\n    if (this.props.beforeChange) {\n      this.props.beforeChange(this.state.currentSlide, currentSlide);\n    }\n\n    if (this.props.lazyLoad) {\n      var loaded = true;\n      var slidesToLoad = [];\n\n      for (var i = targetSlide; i < targetSlide + this.props.slidesToShow; i++) {\n        loaded = loaded && this.state.lazyLoadedList.indexOf(i) >= 0;\n\n        if (!loaded) {\n          slidesToLoad.push(i);\n        }\n      }\n\n      if (!loaded) {\n        this.setState({\n          lazyLoadedList: this.state.lazyLoadedList.concat(slidesToLoad)\n        });\n      }\n    } // Slide Transition happens here.\n    // animated transition happens to target Slide and\n    // non - animated transition happens to current Slide\n    // If CSS transitions are false, directly go the current slide.\n\n    /* istanbul ignore if */\n\n\n    if (this.props.useCSS === false) {\n      this.setState({\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)(_extends({\n          left: currentLeft\n        }, this.props, this.state))\n      }, function () {\n        if (_this2.props.afterChange) {\n          _this2.props.afterChange(currentSlide);\n        }\n      });\n    } else {\n      var nextStateChanges = {\n        animating: false,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackCSS)(_extends({\n          left: currentLeft\n        }, this.props, this.state)),\n        swipeLeft: null\n      };\n\n      callback = function callback() {\n        _this2.setState(nextStateChanges);\n\n        if (_this2.props.afterChange) {\n          _this2.props.afterChange(currentSlide);\n        }\n\n        delete _this2.animationEndCallback;\n      };\n\n      this.setState({\n        animating: true,\n        currentSlide: currentSlide,\n        trackStyle: (0, _trackHelper.getTrackAnimateCSS)(_extends({\n          left: targetLeft\n        }, this.props, this.state))\n      }, function () {\n        this.animationEndCallback = setTimeout(callback, this.props.speed + 20);\n      });\n    }\n\n    this.autoPlay();\n  },\n  // 鼠标悬浮在 arrow 上时作出动画反馈\n  arrowHoverHandler: function arrowHoverHandler(msg) {\n    var offset = 30; // slide 的位置偏移量\n\n    var targetLeft = (0, _trackHelper.getTrackLeft)(_extends({\n      slideIndex: this.state.currentSlide,\n      trackRef: this.track\n    }, this.props, this.state));\n    var left = void 0;\n\n    if (msg === 'next') {\n      left = targetLeft - offset;\n    } else if (msg === 'prev') {\n      left = targetLeft + offset;\n    } else {\n      left = targetLeft;\n    }\n\n    this.setState({\n      trackStyle: (0, _trackHelper.getTrackAnimateCSS)(_extends({\n        left: left\n      }, this.props, this.state))\n    });\n  },\n  swipeDirection: function swipeDirection(touchObject) {\n    var swipeAngle = void 0;\n    var xDist = touchObject.startX - touchObject.curX;\n    var yDist = touchObject.startY - touchObject.curY;\n    var r = Math.atan2(yDist, xDist);\n    swipeAngle = Math.round(r * 180 / Math.PI);\n\n    if (swipeAngle < 0) {\n      swipeAngle = 360 - Math.abs(swipeAngle);\n    }\n\n    if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n      return this.props.rtl === false ? 'left' : 'right';\n    }\n\n    if (swipeAngle >= 135 && swipeAngle <= 225) {\n      return this.props.rtl === false ? 'right' : 'left';\n    }\n\n    if (this.props.verticalSwiping === true) {\n      if (swipeAngle >= 35 && swipeAngle <= 135) {\n        return 'down';\n      } else {\n        return 'up';\n      }\n    }\n\n    return 'vertical';\n  },\n  play: function play() {\n    var nextIndex = void 0;\n\n    if (!this.state.mounted) {\n      return false;\n    }\n\n    if (this.props.rtl) {\n      nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n    } else if (this.canGoNext(_extends({}, this.props, this.state))) {\n      nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n    } else {\n      return false;\n    }\n\n    this.slideHandler(nextIndex);\n  },\n  autoPlay: function autoPlay() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n    }\n\n    if (this.props.autoplay) {\n      this.setState({\n        autoPlayTimer: setTimeout(this.play.bind(this), this.props.autoplaySpeed)\n      });\n    }\n  },\n  pause: function pause() {\n    if (this.state.autoPlayTimer) {\n      clearTimeout(this.state.autoPlayTimer);\n      this.setState({\n        autoPlayTimer: null\n      });\n    }\n  }\n};\nexports['default'] = helpers;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}