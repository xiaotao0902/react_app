{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scaleImage = exports.readFileAsDataURL = exports.uid = undefined;\n\nvar _jpegHeaders = require('./jpeg-headers.js');\n\nvar _jpegHeaders2 = _interopRequireDefault(_jpegHeaders);\n\nvar _exifParser = require('./exif-parser.js');\n\nvar _exifParser2 = _interopRequireDefault(_exifParser);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/* eslint-disable */\n\n\nvar now = +new Date();\n/**\n * 生成唯一的id\n * @return {String} uid\n */\n\nvar uid = exports.uid = function uid() {\n  return (now++).toString(36);\n};\n/**\n * Detect subsampling in loaded image.\n * In iOS, larger images than 2M pixels may be subsampled in rendering.\n */\n\n\nfunction detectSubsampling(img) {\n  var iw = img.naturalWidth;\n  var ih = img.naturalHeight;\n\n  if (iw * ih > 1024 * 1024) {\n    // subsampling may happen over megapixel image\n    var canvas = document.createElement('canvas');\n    canvas.width = canvas.height = 1;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(img, -iw + 1, 0); // subsampled image becomes half smaller in rendering size.\n    // check alpha channel value to confirm image is covering edge pixel or not.\n    // if alpha value is 0 image is not covering, hence subsampled.\n\n    return ctx.getImageData(0, 0, 1, 1).data[3] === 0;\n  } else {\n    return false;\n  }\n}\n/**\n * Detecting vertical squash in loaded image.\n * Fixes a bug which squash image vertically while drawing into canvas for some images.\n */\n\n\nfunction detectVerticalSquash(img, iw, ih) {\n  var canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = ih;\n  var ctx = canvas.getContext('2d');\n  ctx.drawImage(img, 0, 0);\n  var data = ctx.getImageData(0, 0, 1, ih).data; // search image edge pixel position in case it is squashed vertically.\n\n  var sy = 0;\n  var ey = ih;\n  var py = ih;\n\n  while (py > sy) {\n    var alpha = data[(py - 1) * 4 + 3];\n\n    if (alpha === 0) {\n      ey = py;\n    } else {\n      sy = py;\n    }\n\n    py = ey + sy >> 1;\n  }\n\n  var ratio = py / ih;\n  return ratio === 0 ? 1 : ratio;\n}\n/**\n * Rendering image element (with resizing) into the canvas element\n */\n\n\nfunction renderImageToCanvas(img, canvas, width, height) {\n  var iw = img.naturalWidth;\n  var ih = img.naturalHeight;\n  var ctx = canvas.getContext('2d');\n  canvas.width = width;\n  canvas.height = height;\n  ctx.save();\n  var subsampled = detectSubsampling(img);\n\n  if (subsampled) {\n    iw /= 2;\n    ih /= 2;\n  }\n\n  var d = 1024; // size of tiling canvas\n\n  var tilingCanvas = document.createElement('canvas');\n  tilingCanvas.width = tilingCanvas.height = d;\n  var tilingCtx = tilingCanvas.getContext('2d');\n  var vertSquashRatio = detectVerticalSquash(img, iw, ih);\n  var sy = 0;\n\n  while (sy < ih) {\n    var sh = sy + d > ih ? ih - sy : d;\n    var sx = 0;\n\n    while (sx < iw) {\n      var sw = sx + d > iw ? iw - sx : d;\n      tilingCtx.clearRect(0, 0, d, d);\n      tilingCtx.drawImage(img, -sx, -sy);\n      var dx = sx * width / iw << 0;\n      var dw = Math.ceil(sw * width / iw);\n      var dy = sy * height / ih / vertSquashRatio << 0;\n      var dh = Math.ceil(sh * height / ih / vertSquashRatio);\n      ctx.drawImage(tilingCanvas, 0, 0, sw, sh, dx, dy, dw, dh);\n      sx += d;\n    }\n\n    sy += d;\n  }\n\n  ctx.restore();\n  tilingCanvas = tilingCtx = null;\n}\n\nfunction dataHandle(data, canvas, resize, mime) {\n  data = canvas.toDataURL(mime); // Remove data prefix information and grab the base64 encoded data and decode it\n\n  data = data.substring(data.indexOf('base64,') + 7);\n  data = atob(data);\n  return data;\n}\n\nfunction canvasResize(data, resize, mime, cb) {\n  var img = new Image();\n\n  img.onerror = img.onabort = function (err) {\n    throw err || new Error('resize failed');\n  };\n\n  img.onload = function () {\n    var canvas = void 0,\n        width = void 0,\n        height = void 0,\n        scale = void 0,\n        jpegHeaders = void 0,\n        exifParser = void 0;\n    canvas = document.createElement('canvas');\n    canvas.style.display = 'none';\n    document.body.appendChild(canvas); // 图片压缩\n\n    resize.width = resize.width || img.width;\n    resize.height = resize.height || img.height;\n    scale = Math.min(resize.width / img.width, resize.height / img.height);\n\n    if (scale < 1) {\n      width = Math.round(img.width * scale);\n      height = Math.round(img.height * scale);\n    } else {\n      width = img.width;\n      height = img.height;\n    }\n\n    if (width && height) {\n      // Scale image and canvas\n      renderImageToCanvas(img, canvas, width, height); // Preserve JPEG headers\n\n      if (mime === 'image/jpeg') {\n        jpegHeaders = new _jpegHeaders2['default'](atob(data.substring(data.indexOf('base64,') + 7)));\n\n        if (jpegHeaders.headers && jpegHeaders.headers.length) {\n          exifParser = new _exifParser2['default']();\n\n          if (exifParser.init(jpegHeaders.get('exif')[0])) {\n            // Set new width and height\n            exifParser.setExif('PixelXDimension', width);\n            exifParser.setExif('PixelYDimension', height); // Update EXIF header\n\n            jpegHeaders.set('exif', exifParser.getBinary());\n          }\n        }\n      }\n\n      data = dataHandle(data, canvas, resize, mime); // Restore JPEG headers if applicable\n\n      if (jpegHeaders && jpegHeaders.headers && jpegHeaders.headers.length) {\n        data = jpegHeaders.restore(data);\n        jpegHeaders.purge(); // free memory\n      }\n    } else {\n      // Image does not need to be resized\n      data = null;\n    } // Remove canvas and execute callback with decoded image data\n\n\n    canvas.parentNode.removeChild(canvas);\n    data ? cb(data) : function () {\n      throw new Error('resize failed');\n    }();\n  };\n\n  img.src = data;\n} // https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL\n\n\nvar readFileAsDataURL = exports.readFileAsDataURL = function readFileAsDataURL(file, cb) {\n  var reader = new FileReader();\n\n  reader.onloadend = function () {\n    return cb(reader.result);\n  };\n\n  reader.readAsDataURL(file);\n};\n/**\n * 调整图片尺寸\n * @param  {File} file - 文件对象\n * @param  {[type]} resize [description]\n * @param  {[type]} mime   [description]\n * @return {[type]}        [description]\n */\n\n\nvar scaleImage = exports.scaleImage = function scaleImage(file, resize, mime, cb) {\n  return readFileAsDataURL(file, function (data) {\n    return canvasResize(data, resize, mime, cb);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}