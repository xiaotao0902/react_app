{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactDom = require('react-dom');\n\nvar _classnames2 = require('classnames');\n\nvar _classnames3 = _interopRequireDefault(_classnames2);\n\nvar _nextDom = require('../../next-dom/lib/index.js');\n\nvar _nextUtil = require('../../next-util/lib/index.js');\n\nvar _util = require('./util.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n}\n/** Affix */\n\n\nvar Affix = (_temp = _class = function (_React$Component) {\n  _inherits(Affix, _React$Component);\n\n  function Affix(props, context) {\n    _classCallCheck(this, Affix);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    _this._updateNodePosition = function () {\n      var container = _this.props.container;\n      var affixContainer = container();\n      var containerScrollTop = (0, _util.getScroll)(affixContainer, true); // 容器在垂直位置上的滚动 offset\n\n      var affixOffset = _this._getOffset(_this.affixNode, affixContainer); // 目标节点当前相对于容器的 offset\n\n\n      var containerHeight = (0, _util.getNodeHeight)(affixContainer); // 容器的高度\n\n      var affixHeight = _this.affixNode.offsetHeight;\n      var containerRect = (0, _util.getRect)(affixContainer);\n      var affixMode = _this.affixMode;\n\n      if (affixMode.top && containerScrollTop > affixOffset.top - affixMode.offset) {\n        // affix top\n        _this._setAffixStyle({\n          position: 'fixed',\n          top: affixMode.offset + containerRect.top,\n          width: affixOffset.width\n        });\n\n        _this._setContainerStyle({\n          width: affixOffset.width,\n          height: affixHeight\n        });\n      } else if (affixMode.bottom && containerScrollTop < affixOffset.top + affixHeight + affixMode.offset - containerHeight) {\n        // affix bottom\n        _this._setAffixStyle({\n          position: 'fixed',\n          bottom: affixMode.offset,\n          width: affixOffset.width,\n          height: affixHeight\n        });\n\n        _this._setContainerStyle({\n          width: affixOffset.width,\n          height: affixHeight\n        });\n      } else {\n        _this._setAffixStyle(null);\n\n        _this._setContainerStyle(null);\n      }\n    };\n\n    _this._affixNodeRefHandler = function (ref) {\n      _this.affixNode = (0, _reactDom.findDOMNode)(ref);\n    };\n\n    _this.state = {\n      style: null,\n      containerStyle: null\n    };\n    _this.affixMode = _this._getAffixMode(props);\n    return _this;\n  }\n\n  Affix.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var container = this.props.container; // wait for parent rendered\n\n    this.timeout = setTimeout(function () {\n      _this2._setEventHandlerForContainer(container);\n    });\n  };\n\n  Affix.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n\n    var container = this.props.container;\n\n    this._removeEventHandlerForContainer(container);\n  };\n\n  Affix.prototype._setEventHandlerForContainer = function _setEventHandlerForContainer(getContainer) {\n    var container = getContainer();\n\n    if (!container) {\n      return;\n    }\n\n    _nextDom.events.on(container, 'scroll', this._updateNodePosition);\n\n    _nextDom.events.on(container, 'resize', this._updateNodePosition);\n  };\n\n  Affix.prototype._removeEventHandlerForContainer = function _removeEventHandlerForContainer(getContainer) {\n    var container = getContainer();\n\n    if (container) {\n      _nextDom.events.off(container, 'scroll', this._updateNodePosition);\n\n      _nextDom.events.off(container, 'resize', this._updateNodePosition);\n    }\n  };\n\n  Affix.prototype._getAffixMode = function _getAffixMode() {\n    var _props = this.props,\n        offsetTop = _props.offsetTop,\n        offsetBottom = _props.offsetBottom;\n    var affixMode = {\n      top: false,\n      bottom: false,\n      offset: 0\n    };\n\n    if (typeof offsetTop !== 'number' && typeof offsetBottom !== 'number') {\n      // set default\n      affixMode.top = true;\n    } else if (typeof offsetTop === 'number') {\n      affixMode.top = true;\n      affixMode.offset = offsetTop;\n    } else if (typeof offsetBottom === 'number') {\n      affixMode.bottom = true;\n      affixMode.offset = offsetBottom;\n    }\n\n    return affixMode;\n  };\n\n  Affix.prototype._setAffixStyle = function _setAffixStyle(affixStyle) {\n    if (_nextUtil.obj.shallowEqual(affixStyle, this.state.style)) {\n      return;\n    }\n\n    this.setState({\n      style: affixStyle\n    });\n    var onAffix = this.props.onAffix;\n\n    if (affixStyle && affixStyle.position === 'fixed') {\n      onAffix(true);\n    } else {\n      onAffix(false);\n    }\n  };\n\n  Affix.prototype._setContainerStyle = function _setContainerStyle(containerStyle) {\n    if (_nextUtil.obj.shallowEqual(containerStyle, this.state.containerStyle)) {\n      return;\n    }\n\n    this.setState({\n      containerStyle: containerStyle\n    });\n  };\n\n  Affix.prototype._getOffset = function _getOffset(affixNode, affixContainer) {\n    var affixRect = affixNode.getBoundingClientRect(); // affix 元素 相对浏览器窗口的位置\n\n    var containerRect = (0, _util.getRect)(affixContainer); // affix 容器 相对浏览器窗口的位置\n\n    var containerScrollTop = (0, _util.getScroll)(affixContainer, true);\n    var containerScrollLeft = (0, _util.getScroll)(affixContainer, false);\n    return {\n      top: affixRect.top - containerRect.top + containerScrollTop,\n      left: affixRect.left - containerRect.left + containerScrollLeft,\n      width: affixRect.width,\n      height: affixRect.height\n    };\n  };\n\n  Affix.prototype.render = function render() {\n    var _classnames;\n\n    var _props2 = this.props,\n        className = _props2.className,\n        children = _props2.children,\n        style = _props2.style;\n    var state = this.state;\n    var prefix = this.context.prefix || this.props.prefix;\n    var classNames = (0, _classnames3['default'])((_classnames = {}, _defineProperty(_classnames, prefix + 'affix', state.style), _defineProperty(_classnames, prefix + 'affix-top', !state.style && this.affixMode.top), _defineProperty(_classnames, prefix + 'affix-bottom', !state.style && this.affixMode.bottom), _defineProperty(_classnames, className, className), _classnames));\n\n    var combinedStyle = _extends({}, state.containerStyle, style);\n\n    return _react2['default'].createElement('div', {\n      ref: this._affixNodeRefHandler,\n      style: combinedStyle\n    }, _react2['default'].createElement('div', {\n      className: classNames,\n      style: state.style\n    }, children));\n  };\n\n  return Affix;\n}(_react2['default'].Component), _class.contextTypes = {\n  prefix: _propTypes2['default'].string\n}, _class.propTypes = {\n  /**\n   * 品牌样式前缀\n   */\n  prefix: _propTypes2['default'].string,\n\n  /**\n   * 设置 Affix 需要监听滚动事件的容器元素\n   * @return {ReactElement} 目标容器元素的实例\n   */\n  container: _propTypes2['default'].func,\n\n  /**\n   * 距离窗口顶部达到指定偏移量后触发\n   */\n  offsetTop: _propTypes2['default'].number,\n\n  /**\n   * 距离窗口底部达到制定偏移量后触发\n   */\n  offsetBottom: _propTypes2['default'].number,\n\n  /**\n   * 当元素的样式发生固钉样式变化时触发的回调函数\n   * @param {Boolean} affixed 元素是否被固钉\n   */\n  onAffix: _propTypes2['default'].func,\n\n  /**\n   * 自定义样式类名\n   */\n  className: _propTypes2['default'].string,\n  style: _propTypes2['default'].object,\n  children: _propTypes2['default'].any\n}, _class.defaultProps = {\n  prefix: 'next-',\n  container: function container() {\n    return window;\n  },\n  onAffix: function onAffix() {}\n}, _temp);\nAffix.displayName = 'Affix';\nexports['default'] = Affix;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}