{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = undefined;\n\nvar _class, _temp;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _nextDom = require('../../next-dom/lib/index.js');\n\nvar _classnames2 = require('classnames');\n\nvar _classnames3 = _interopRequireDefault(_classnames2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);\n}\n\nvar Children = _react2['default'].Children,\n    place = _nextDom.position.place,\n    noop = function noop() {};\n/** Overlay.Position */\n\n\nvar Position = (_temp = _class = function (_React$Component) {\n  _inherits(Position, _React$Component);\n\n  function Position(props) {\n    _classCallCheck(this, Position);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    ['resize', 'setPosition'].forEach(function (method) {\n      _this[method] = _this[method].bind(_this);\n    });\n    return _this;\n  }\n\n  Position.prototype.resize = function resize() {\n    var _this2 = this;\n\n    if (this.resizeTimeout) {\n      clearTimeout(this.resizeTimeout);\n    }\n\n    this.resizeTimeout = setTimeout(function () {\n      _this2.setPosition();\n    }, 200);\n  };\n\n  Position.prototype.render = function render() {\n    var _classnames;\n\n    var child = Children.only(this.props.children),\n        propClassName = this.props.className,\n        childClassName = child.props.className,\n        className = (0, _classnames3['default'])((_classnames = {}, _defineProperty(_classnames, propClassName, propClassName), _defineProperty(_classnames, childClassName, childClassName), _classnames));\n    return _react2['default'].cloneElement(child, {\n      className: className\n    });\n  };\n\n  Position.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if ('align' in nextProps && nextProps.align !== this.props.align || nextProps.shouldUpdatePosition) {\n      this.shouldUpdatePosition = true;\n    }\n  };\n\n  Position.prototype.componentDidMount = function componentDidMount() {\n    this.setPosition();\n\n    if (this.props.needListenResize) {\n      _nextDom.events.on(window, 'resize', this.resize);\n    }\n  };\n\n  Position.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.props.needListenResize) {\n      _nextDom.events.off(window, 'resize', this.resize);\n    }\n\n    if (this.resizeTimeout) {\n      clearTimeout(this.resizeTimeout);\n    }\n  };\n\n  Position.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldUpdatePosition) {\n      this.setPosition();\n      this.shouldUpdatePosition = false;\n    }\n  };\n\n  Position.prototype.setPosition = function setPosition() {\n    var align = this.props.align,\n        offset = this.props.offset,\n        contentNode = this.getContentNode(),\n        target = this.getTarget();\n    this.props.beforePosition();\n\n    if (target && contentNode) {\n      var resultAlign = place(contentNode, target, align, offset, this.props.needAdjust, this.props.isRtl);\n\n      var left = _nextDom.style.get(contentNode, 'left'),\n          top = _nextDom.style.get(contentNode, 'top');\n\n      this.props.onPosition({\n        left: left,\n        top: top,\n        align: resultAlign.split(' ')\n      }, contentNode);\n    }\n  };\n\n  Position.prototype.getContentNode = function getContentNode() {\n    return _reactDom2['default'].findDOMNode(this);\n  };\n\n  Position.prototype.getTarget = function getTarget() {\n    var target = this.props.target;\n\n    if (!target) {\n      return null;\n    }\n\n    if (typeof target === 'function') {\n      target = target(this.props);\n    }\n\n    if (typeof target === 'string' && target !== _nextDom.position.VIEWPORT) {\n      target = document.getElementById(target);\n    } else {\n      try {\n        target = _reactDom2['default'].findDOMNode(target);\n      } catch (err) {// continue regardless of error\n      }\n    }\n\n    return target;\n  };\n\n  return Position;\n}(_react2['default'].Component), _class.propTypes = {\n  /**\n   * 自定义类名\n   */\n  className: _propTypes2['default'].string,\n  children: _propTypes2['default'].any,\n\n  /**\n   * 定位参照的元素\n   */\n  target: _propTypes2['default'].any,\n\n  /**\n   * 定位的目标元素\n   */\n  contentNode: _propTypes2['default'].any,\n\n  /**\n   * 定位的方式, 详见开发指南的[定位部分](#定位)\n   */\n  align: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].bool]),\n\n  /**\n   * 相对于target定位的微调\n   */\n  offset: _propTypes2['default'].array,\n\n  /**\n   * 定位完成前触发的事件\n   */\n  beforePosition: _propTypes2['default'].func,\n\n  /**\n   * 定位完成后触发的事件\n   * @param {Object} config 定位的参数\n   * @param {Object} node 定位的元素\n   */\n  onPosition: _propTypes2['default'].func,\n\n  /**\n   * 是否自动调整定位的位置\n   */\n  needAdjust: _propTypes2['default'].bool,\n\n  /**\n   * 是否监听Resize事件\n   */\n  needListenResize: _propTypes2['default'].bool,\n\n  /**\n   * 强制更新定位信息\n   */\n  shouldUpdatePosition: _propTypes2['default'].bool,\n\n  /**\n   * 对齐方式\n   */\n  isRtl: _propTypes2['default'].bool\n}, _class.defaultProps = {\n  align: 'tl bl',\n  offset: [0, 0],\n  isRtl: false,\n  beforePosition: noop,\n  onPosition: noop,\n  needAdjust: true,\n  needListenResize: true,\n  shouldUpdatePosition: false\n}, _temp);\nPosition.displayName = 'Position';\nexports['default'] = Position;\nPosition.VIEWPORT = _nextDom.position.VIEWPORT;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}