{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _binaryReader = require('./binary-reader.js');\n\nvar _binaryReader2 = _interopRequireDefault(_binaryReader);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/* eslint-disable */\n\n\nvar ExifParser = function () {\n  function ExifParser() {\n    _classCallCheck(this, ExifParser); // Private ExifParser fields\n\n\n    this.data = new _binaryReader2['default']();\n    this.offsets = {};\n    this.tags = {\n      tiff: {\n        /*\n         The image orientation viewed in terms of rows and columns.\n          1 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.\n         2 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.\n         3 - The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.\n         4 - The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.\n         5 - The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.\n         6 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.\n         7 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.\n         8 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.\n         9 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.\n         */\n        0x0112: 'Orientation',\n        0x8769: 'ExifIFDPointer',\n        0x8825: 'GPSInfoIFDPointer'\n      },\n      exif: {\n        0x9000: 'ExifVersion',\n        0xA001: 'ColorSpace',\n        0xA002: 'PixelXDimension',\n        0xA003: 'PixelYDimension',\n        0x9003: 'DateTimeOriginal',\n        0x829A: 'ExposureTime',\n        0x829D: 'FNumber',\n        0x8827: 'ISOSpeedRatings',\n        0x9201: 'ShutterSpeedValue',\n        0x9202: 'ApertureValue',\n        0x9207: 'MeteringMode',\n        0x9208: 'LightSource',\n        0x9209: 'Flash',\n        0xA402: 'ExposureMode',\n        0xA403: 'WhiteBalance',\n        0xA406: 'SceneCaptureType',\n        0xA404: 'DigitalZoomRatio',\n        0xA408: 'Contrast',\n        0xA409: 'Saturation',\n        0xA40A: 'Sharpness'\n      },\n      gps: {\n        0x0000: 'GPSVersionID',\n        0x0001: 'GPSLatitudeRef',\n        0x0002: 'GPSLatitude',\n        0x0003: 'GPSLongitudeRef',\n        0x0004: 'GPSLongitude'\n      }\n    };\n    this.tagDescs = {\n      'ColorSpace': {\n        1: 'sRGB',\n        0: 'Uncalibrated'\n      },\n      'MeteringMode': {\n        0: 'Unknown',\n        1: 'Average',\n        2: 'CenterWeightedAverage',\n        3: 'Spot',\n        4: 'MultiSpot',\n        5: 'Pattern',\n        6: 'Partial',\n        255: 'Other'\n      },\n      'LightSource': {\n        1: 'Daylight',\n        2: 'Fliorescent',\n        3: 'Tungsten',\n        4: 'Flash',\n        9: 'Fine weather',\n        10: 'Cloudy weather',\n        11: 'Shade',\n        12: 'Daylight fluorescent (D 5700 - 7100K)',\n        13: 'Day white fluorescent (N 4600 -5400K)',\n        14: 'Cool white fluorescent (W 3900 - 4500K)',\n        15: 'White fluorescent (WW 3200 - 3700K)',\n        17: 'Standard light A',\n        18: 'Standard light B',\n        19: 'Standard light C',\n        20: 'D55',\n        21: 'D65',\n        22: 'D75',\n        23: 'D50',\n        24: 'ISO studio tungsten',\n        255: 'Other'\n      },\n      'Flash': {\n        0x0000: 'Flash did not fire.',\n        0x0001: 'Flash fired.',\n        0x0005: 'Strobe return light not detected.',\n        0x0007: 'Strobe return light detected.',\n        0x0009: 'Flash fired, compulsory flash mode',\n        0x000D: 'Flash fired, compulsory flash mode, return light not detected',\n        0x000F: 'Flash fired, compulsory flash mode, return light detected',\n        0x0010: 'Flash did not fire, compulsory flash mode',\n        0x0018: 'Flash did not fire, auto mode',\n        0x0019: 'Flash fired, auto mode',\n        0x001D: 'Flash fired, auto mode, return light not detected',\n        0x001F: 'Flash fired, auto mode, return light detected',\n        0x0020: 'No flash function',\n        0x0041: 'Flash fired, red-eye reduction mode',\n        0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n        0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n        0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n        0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n        0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n        0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n        0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n        0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n      },\n      'ExposureMode': {\n        0: 'Auto exposure',\n        1: 'Manual exposure',\n        2: 'Auto bracket'\n      },\n      'WhiteBalance': {\n        0: 'Auto white balance',\n        1: 'Manual white balance'\n      },\n      'SceneCaptureType': {\n        0: 'Standard',\n        1: 'Landscape',\n        2: 'Portrait',\n        3: 'Night scene'\n      },\n      'Contrast': {\n        0: 'Normal',\n        1: 'Soft',\n        2: 'Hard'\n      },\n      'Saturation': {\n        0: 'Normal',\n        1: 'Low saturation',\n        2: 'High saturation'\n      },\n      'Sharpness': {\n        0: 'Normal',\n        1: 'Soft',\n        2: 'Hard'\n      },\n      // GPS related\n      'GPSLatitudeRef': {\n        N: 'North latitude',\n        S: 'South latitude'\n      },\n      'GPSLongitudeRef': {\n        E: 'East longitude',\n        W: 'West longitude'\n      }\n    };\n  }\n\n  ExifParser.prototype._extractTags = function _extractTags(IFD_offset, tags2extract) {\n    var data = this.data,\n        offsets = this.offsets,\n        tagDescs = this.tagDescs;\n    var length = data.SHORT(IFD_offset),\n        i = void 0,\n        ii = void 0,\n        tag = void 0,\n        type = void 0,\n        count = void 0,\n        tagOffset = void 0,\n        offset = void 0,\n        value = void 0,\n        values = [],\n        hash = {};\n\n    for (i = 0; i < length; i++) {\n      // Set binary reader pointer to beginning of the next tag\n      offset = tagOffset = IFD_offset + 12 * i + 2;\n      tag = tags2extract[data.SHORT(offset)];\n\n      if (tag === undefined) {\n        continue; // Not the tag we requested\n      }\n\n      type = data.SHORT(offset += 2);\n      count = data.LONG(offset += 2);\n      offset += 4;\n      values = [];\n\n      switch (type) {\n        case 1: // BYTE\n\n        case 7:\n          // UNDEFINED\n          if (count > 4) {\n            offset = data.LONG(offset) + offsets.tiffHeader;\n          }\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.BYTE(offset + ii);\n          }\n\n          break;\n\n        case 2:\n          // STRING\n          if (count > 4) {\n            offset = data.LONG(offset) + offsets.tiffHeader;\n          }\n\n          hash[tag] = data.STRING(offset, count - 1);\n          continue;\n\n        case 3:\n          // SHORT\n          if (count > 2) {\n            offset = data.LONG(offset) + offsets.tiffHeader;\n          }\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.SHORT(offset + ii * 2);\n          }\n\n          break;\n\n        case 4:\n          // LONG\n          if (count > 1) {\n            offset = data.LONG(offset) + offsets.tiffHeader;\n          }\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.LONG(offset + ii * 4);\n          }\n\n          break;\n\n        case 5:\n          // RATIONAL\n          offset = data.LONG(offset) + offsets.tiffHeader;\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.LONG(offset + ii * 4) / data.LONG(offset + ii * 4 + 4);\n          }\n\n          break;\n\n        case 9:\n          // SLONG\n          offset = data.LONG(offset) + offsets.tiffHeader;\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.SLONG(offset + ii * 4);\n          }\n\n          break;\n\n        case 10:\n          // SRATIONAL\n          offset = data.LONG(offset) + offsets.tiffHeader;\n\n          for (ii = 0; ii < count; ii++) {\n            values[ii] = data.SLONG(offset + ii * 4) / data.SLONG(offset + ii * 4 + 4);\n          }\n\n          break;\n\n        default:\n          continue;\n      }\n\n      value = count == 1 ? values[0] : values;\n\n      if (tagDescs.hasOwnProperty(tag) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) != 'object') {\n        hash[tag] = tagDescs[tag][value];\n      } else {\n        hash[tag] = value;\n      }\n    }\n\n    return hash;\n  };\n\n  ExifParser.prototype.init = function init(segment) {\n    var data = this.data,\n        offsets = this.offsets,\n        tags = this.tags; // Reset internal data\n\n    offsets = {\n      tiffHeader: 10\n    };\n\n    if (segment === undefined || !segment.length) {\n      return false;\n    }\n\n    data.init(segment); // Check if that's APP1 and that it has EXIF\n\n    if (data.SHORT(0) === 0xFFE1 && this.data.STRING(4, 5).toUpperCase() === 'EXIF\\0') {\n      var Tiff = undefined;\n      var idx = this.offsets.tiffHeader; // Set read order of multi-byte data\n\n      this.data.II(data.SHORT(idx) == 0x4949); // Check if always present bytes are indeed present\n\n      if (data.SHORT(idx += 2) !== 0x002A) return false;\n      offsets['IFD0'] = offsets.tiffHeader + data.LONG(idx += 2);\n      Tiff = this._extractTags(offsets['IFD0'], tags.tiff);\n      offsets['exifIFD'] = 'ExifIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.ExifIFDPointer : undefined;\n      offsets['gpsIFD'] = 'GPSInfoIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.GPSInfoIFDPointer : undefined;\n      return true;\n    }\n\n    return false;\n  };\n\n  ExifParser.prototype.EXIF = function EXIF() {\n    var offsets = this.offsets,\n        tags = this.tags; // Populate EXIF hash\n\n    var Exif = this._extractTags(offsets.exifIFD, tags.exif); // Fix formatting of some tags\n\n\n    if (Exif.ExifVersion && Array.isArray(Exif.ExifVersion)) {\n      for (var i = 0, _exifVersion = ''; i < Exif.ExifVersion.length; i++) {\n        _exifVersion += String.fromCharCode(Exif.ExifVersion[i]);\n      }\n\n      Exif.ExifVersion = exifVersion;\n    }\n\n    return Exif;\n  };\n\n  ExifParser.prototype.GPS = function GPS() {\n    var offsets = this.offsets,\n        tags = this.tags;\n\n    var GPS = this._extractTags(offsets.gpsIFD, tags.gps); // iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)\n    // fixbug GPS.GPSVersionID maybe string add by david.chenz 2015.01.13\n\n\n    if (GPS.GPSVersionID && Array.isArray(GPS.GPSVersionID)) {\n      GPS.GPSVersionID = GPS.GPSVersionID.join('.');\n    }\n\n    return GPS;\n  };\n\n  ExifParser.prototype.setExif = function setExif(tag, value) {\n    var data = this.data,\n        offsets = this.offsets,\n        tags = this.tags; // Right now only setting of width/height is possible\n\n    if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') {\n      return false;\n    }\n\n    var offset = void 0,\n        length = void 0,\n        tagOffset = void 0,\n        valueOffset = 0; // If tag name passed translate into hex key\n\n    if (typeof tag === 'string') {\n      var tmpTags = tags['exif'];\n\n      for (var hex in tmpTags) {\n        if (tmpTags[hex] === tag) {\n          tag = hex;\n          break;\n        }\n      }\n    }\n\n    offset = offsets['exifIFD'];\n    length = data.SHORT(offset);\n\n    for (var i = 0; i < length; i++) {\n      tagOffset = offset + 12 * i + 2;\n\n      if (data.SHORT(tagOffset) == tag) {\n        valueOffset = tagOffset + 8;\n        break;\n      }\n    }\n\n    if (!valueOffset) {\n      return false;\n    }\n\n    data.LONG(valueOffset, value);\n    return true;\n  };\n\n  ExifParser.prototype.getBinary = function getBinary() {\n    return this.data.SEGMENT();\n  };\n\n  return ExifParser;\n}();\n\nexports['default'] = ExifParser;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}